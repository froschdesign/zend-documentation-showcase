{
    "docs": [
        {
            "location": "/", 
            "text": "../../README.md", 
            "title": "Home"
        }, 
        {
            "location": "/intro/", 
            "text": "Introduction\n\n\nzend-validator provides a set of commonly needed validators. It also provides a\nsimple validator chaining mechanism by which multiple validators may be applied\nto a single datum in a user-defined order.\n\n\nWhat is a validator?\n\n\nA validator examines its input with respect to some requirements and produces a\nboolean result indicating whether the input successfully validates against the\nrequirements. If the input does not meet the requirements, a validator may\nadditionally provide information about which requirement(s) the input does not\nmeet.\n\n\nFor example, a web application might require that a username be between six and\ntwelve characters in length, and may only contain alphanumeric characters. A\nvalidator can be used for ensuring that a username meets these requirements. If\na chosen username does not meet one or both of the requirements, it would be\nuseful to know which of the requirements the username fails to meet.\n\n\nBasic usage of validators\n\n\nHaving defined validation in this way provides the foundation for\n\nZend\\Validator\\ValidatorInterface\n, which defines two methods, \nisValid()\n and\n\ngetMessages()\n. The \nisValid()\n method performs validation upon the provided\nvalue, returning \ntrue\n if and only if the value passes against the validation\ncriteria.\n\n\nIf \nisValid()\n returns \nfalse\n, the \ngetMessages()\n method will return an array\nof messages explaining the reason(s) for validation failure. The array keys are\nshort strings that identify the reasons for validation failure, and the array\nvalues are the corresponding human-readable string messages. The keys and values\nare class-dependent; each validation class defines its own set of validation\nfailure messages and the unique keys that identify them. Each class also has a\n\nconst\n definition that matches each identifier for a validation failure cause.\n\n\n\n\nStateful validators\n\n\nThe \ngetMessages()\n methods return validation failure information only for the\nmost recent \nisValid()\n call. Each call to \nisValid()\n clears any messages and\nerrors caused by a previous \nisValid()\n call, because it's likely that each\ncall to \nisValid()\n is made for a different input value.\n\n\n\n\nThe following example illustrates validation of an e-mail address:\n\n\nuse Zend\\Validator\\EmailAddress;\n\n$validator = new EmailAddress();\n\nif ($validator-\nisValid($email)) {\n    // email appears to be valid\n} else {\n    // email is invalid; print the reasons\n    foreach ($validator-\ngetMessages() as $messageId =\n $message) {\n        printf(\nValidation failure '%s': %s\\n\n, $messageId, $message);\n    }\n}\n\n\n\n\nCustomizing messages\n\n\nValidator classes provide a \nsetMessage()\n method with which you can specify the\nformat of a message returned by \ngetMessages()\n in case of validation failure.\nThe first argument of this method is a string containing the error message. You\ncan include tokens in this string which will be substituted with data relevant\nto the validator. The token \n%value%\n is supported by all validators; this is\nsubstituted with the value you passed to \nisValid()\n. Other tokens may be\nsupported on a case-by-case basis in each validation class. For example, \n%max%\n\nis a token supported by \nZend\\Validator\\LessThan\n. The \ngetMessageVariables()\n\nmethod returns an array of variable tokens supported by the validator.\n\n\nThe second optional argument is a string that identifies the validation failure\nmessage template to be set, which is useful when a validation class defines more\nthan one cause for failure. If you omit the second argument, \nsetMessage()\n\nassumes the message you specify should be used for the first message template\ndeclared in the validation class. Many validation classes only have one error\nmessage template defined, so there is no need to specify which message template\nyou are changing.\n\n\nuse Zend\\Validator\\StringLength;\n\n$validator = new StringLength(8);\n\n$validator-\nsetMessage(\n    'The string \\'%value%\\' is too short; it must be at least %min% characters',\n    StringLength::TOO_SHORT\n);\n\nif (! $validator-\nisValid('word')) {\n    $messages = $validator-\ngetMessages();\n    echo current($messages);\n\n    // \nThe string 'word' is too short; it must be at least 8 characters\n\n}\n\n\n\n\nYou can set multiple messages using the \nsetMessages()\n method. Its argument is\nan array containing key/message pairs.\n\n\nuse Zend\\Validator\\StringLength;\n\n$validator = new StringLength(['min' =\n 8, 'max' =\n 12]);\n\n$validator-\nsetMessages([\n    StringLength::TOO_SHORT =\n 'The string \\'%value%\\' is too short',\n    StringLength::TOO_LONG  =\n 'The string \\'%value%\\' is too long',\n]);\n\n\n\n\nIf your application requires even greater flexibility with which it reports\nvalidation failures, you can access properties by the same name as the message\ntokens supported by a given validation class. The \nvalue\n property is always\navailable in a validator; it is the value you specified as the argument of\n\nisValid()\n. Other properties may be supported on a case-by-case basis in each\nvalidation class.\n\n\nuse Zend\\Validator\\StringLength;\n\n$validator = new StringLength(['min' =\n 8, 'max' =\n 12]);\n\nif (! $validator-\nisValid('word')) {\n    printf(\n        \nWord failed: %s; its length is not between %d and %d\\n\n,\n        $validator-\nvalue,\n        $validator-\nmin,\n        $validator-\nmax\n    );\n}\n\n\n\n\nTranslating messages\n\n\n\n\nTranslation compatibility\n\n\nIn versions 2.0 - 2.1, \nZend\\Validator\\AbstractValidator\n implemented\n\nZend\\I18n\\Translator\\TranslatorAwareInterface\n and accepted instances of\n\nZend\\I18n\\Translator\\Translator\n. Starting in version 2.2.0, zend-validator\nnow defines a translator interface, \n \nZend\\Validator\\Translator\\TranslatorInterface\n,\nas well as it's own -aware variant, \n \nZend\\Validator\\Translator\\TranslatorAwareInterface\n.\nThis was done to reduce dependencies for the component, and follows the\nprincipal of Separated Interfaces.\n\n\nThe upshot is that if you are migrating from a pre-2.2 version, and receiving\nerrors indicating that the translator provided does not implement\n\nZend\\Validator\\Translator\\TranslatorInterface\n, you will need to make a\nchange to your code.\n\n\nAn implementation of \nZend\\Validator\\Translator\\TranslatorInterface\n is\nprovided in \nZend\\Mvc\\I18n\\Translator\n, which also extends\n\nZend\\I18n\\Translator\\Translator\n. This version can be instantiated and used\njust as the original \nZend\\I18n\n version.\n\n\nA new service has also been registered with the MVC, \nMvcTranslator\n, which\nwill return this specialized, bridge instance.\n\n\nMost users should see no issues, as \nZend\\Validator\\ValidatorPluginManager\n\nhas been modified to use the \nMvcTranslator\n service internally, which is how\nmost developers were getting the translator instance into validators in the\nfirst place. You will only need to change code if you were manually injecting\nthe instance previously.\n\n\n\n\nValidator classes provide a \nsetTranslator()\n method with which you can specify\nan instance of \nZend\\Validator\\Translator\\TranslatorInterface\n which will\ntranslate the messages in case of a validation failure. The \ngetTranslator()\n\nmethod returns the translator instance. \nZend\\Mvc\\I18n\\Translator\n provides an\nimplementation compatible with the validator component.\n\n\nuse Zend\\Mvc\\I18n\\Translator;\nuse Zend\\Validator\\StringLength;\n\n$validator = new StringLength(['min' =\n 8, 'max' =\n 12]);\n$translate = new Translator();\n// configure the translator...\n\n$validator-\nsetTranslator($translate);\n\n\n\n\nWith the static \nAbstractValidator::setDefaultTranslator()\n method you can set a\ninstance of \nZend\\Validator\\Translator\\TranslatorInterface\n which will be used\nfor all validation classes, and can be retrieved with \ngetDefaultTranslator()\n.\nThis prevents the need for setting a translator manually with each validator.\n\n\nuse Zend\\Mvc\\I18n\\Translator;\nuse Zend\\Validator\\AbstractValidator;\n\n$translate = new Translator();\n// configure the translator...\n\nAbstractValidator::setDefaultTranslator($translate);\n\n\n\n\nSometimes it is necessary to disable the translator within a validator. To\nachieve this you can use the \nsetDisableTranslator()\n method, which accepts a\nboolean parameter, and \nisTranslatorDisabled()\n to get the set value.\n\n\nuse Zend\\Validator\\StringLength;\n\n$validator = new StringLength(['min' =\n 8, 'max' =\n 12]);\nif (! $validator-\nisTranslatorDisabled()) {\n    $validator-\nsetDisableTranslator();\n}\n\n\n\n\nIt is also possible to use a translator instead of setting own messages with\n\nsetMessage()\n. But doing so, you should keep in mind, that the translator works\nalso on messages you set your own.", 
            "title": "Intro"
        }, 
        {
            "location": "/intro/#introduction", 
            "text": "zend-validator provides a set of commonly needed validators. It also provides a\nsimple validator chaining mechanism by which multiple validators may be applied\nto a single datum in a user-defined order.", 
            "title": "Introduction"
        }, 
        {
            "location": "/intro/#what-is-a-validator", 
            "text": "A validator examines its input with respect to some requirements and produces a\nboolean result indicating whether the input successfully validates against the\nrequirements. If the input does not meet the requirements, a validator may\nadditionally provide information about which requirement(s) the input does not\nmeet.  For example, a web application might require that a username be between six and\ntwelve characters in length, and may only contain alphanumeric characters. A\nvalidator can be used for ensuring that a username meets these requirements. If\na chosen username does not meet one or both of the requirements, it would be\nuseful to know which of the requirements the username fails to meet.", 
            "title": "What is a validator?"
        }, 
        {
            "location": "/intro/#basic-usage-of-validators", 
            "text": "Having defined validation in this way provides the foundation for Zend\\Validator\\ValidatorInterface , which defines two methods,  isValid()  and getMessages() . The  isValid()  method performs validation upon the provided\nvalue, returning  true  if and only if the value passes against the validation\ncriteria.  If  isValid()  returns  false , the  getMessages()  method will return an array\nof messages explaining the reason(s) for validation failure. The array keys are\nshort strings that identify the reasons for validation failure, and the array\nvalues are the corresponding human-readable string messages. The keys and values\nare class-dependent; each validation class defines its own set of validation\nfailure messages and the unique keys that identify them. Each class also has a const  definition that matches each identifier for a validation failure cause.", 
            "title": "Basic usage of validators"
        }, 
        {
            "location": "/intro/#stateful-validators", 
            "text": "The  getMessages()  methods return validation failure information only for the\nmost recent  isValid()  call. Each call to  isValid()  clears any messages and\nerrors caused by a previous  isValid()  call, because it's likely that each\ncall to  isValid()  is made for a different input value.   The following example illustrates validation of an e-mail address:  use Zend\\Validator\\EmailAddress;\n\n$validator = new EmailAddress();\n\nif ($validator- isValid($email)) {\n    // email appears to be valid\n} else {\n    // email is invalid; print the reasons\n    foreach ($validator- getMessages() as $messageId =  $message) {\n        printf( Validation failure '%s': %s\\n , $messageId, $message);\n    }\n}", 
            "title": "Stateful validators"
        }, 
        {
            "location": "/intro/#customizing-messages", 
            "text": "Validator classes provide a  setMessage()  method with which you can specify the\nformat of a message returned by  getMessages()  in case of validation failure.\nThe first argument of this method is a string containing the error message. You\ncan include tokens in this string which will be substituted with data relevant\nto the validator. The token  %value%  is supported by all validators; this is\nsubstituted with the value you passed to  isValid() . Other tokens may be\nsupported on a case-by-case basis in each validation class. For example,  %max% \nis a token supported by  Zend\\Validator\\LessThan . The  getMessageVariables() \nmethod returns an array of variable tokens supported by the validator.  The second optional argument is a string that identifies the validation failure\nmessage template to be set, which is useful when a validation class defines more\nthan one cause for failure. If you omit the second argument,  setMessage() \nassumes the message you specify should be used for the first message template\ndeclared in the validation class. Many validation classes only have one error\nmessage template defined, so there is no need to specify which message template\nyou are changing.  use Zend\\Validator\\StringLength;\n\n$validator = new StringLength(8);\n\n$validator- setMessage(\n    'The string \\'%value%\\' is too short; it must be at least %min% characters',\n    StringLength::TOO_SHORT\n);\n\nif (! $validator- isValid('word')) {\n    $messages = $validator- getMessages();\n    echo current($messages);\n\n    //  The string 'word' is too short; it must be at least 8 characters \n}  You can set multiple messages using the  setMessages()  method. Its argument is\nan array containing key/message pairs.  use Zend\\Validator\\StringLength;\n\n$validator = new StringLength(['min' =  8, 'max' =  12]);\n\n$validator- setMessages([\n    StringLength::TOO_SHORT =  'The string \\'%value%\\' is too short',\n    StringLength::TOO_LONG  =  'The string \\'%value%\\' is too long',\n]);  If your application requires even greater flexibility with which it reports\nvalidation failures, you can access properties by the same name as the message\ntokens supported by a given validation class. The  value  property is always\navailable in a validator; it is the value you specified as the argument of isValid() . Other properties may be supported on a case-by-case basis in each\nvalidation class.  use Zend\\Validator\\StringLength;\n\n$validator = new StringLength(['min' =  8, 'max' =  12]);\n\nif (! $validator- isValid('word')) {\n    printf(\n         Word failed: %s; its length is not between %d and %d\\n ,\n        $validator- value,\n        $validator- min,\n        $validator- max\n    );\n}", 
            "title": "Customizing messages"
        }, 
        {
            "location": "/intro/#translating-messages", 
            "text": "", 
            "title": "Translating messages"
        }, 
        {
            "location": "/intro/#translation-compatibility", 
            "text": "In versions 2.0 - 2.1,  Zend\\Validator\\AbstractValidator  implemented Zend\\I18n\\Translator\\TranslatorAwareInterface  and accepted instances of Zend\\I18n\\Translator\\Translator . Starting in version 2.2.0, zend-validator\nnow defines a translator interface,    Zend\\Validator\\Translator\\TranslatorInterface ,\nas well as it's own -aware variant,    Zend\\Validator\\Translator\\TranslatorAwareInterface .\nThis was done to reduce dependencies for the component, and follows the\nprincipal of Separated Interfaces.  The upshot is that if you are migrating from a pre-2.2 version, and receiving\nerrors indicating that the translator provided does not implement Zend\\Validator\\Translator\\TranslatorInterface , you will need to make a\nchange to your code.  An implementation of  Zend\\Validator\\Translator\\TranslatorInterface  is\nprovided in  Zend\\Mvc\\I18n\\Translator , which also extends Zend\\I18n\\Translator\\Translator . This version can be instantiated and used\njust as the original  Zend\\I18n  version.  A new service has also been registered with the MVC,  MvcTranslator , which\nwill return this specialized, bridge instance.  Most users should see no issues, as  Zend\\Validator\\ValidatorPluginManager \nhas been modified to use the  MvcTranslator  service internally, which is how\nmost developers were getting the translator instance into validators in the\nfirst place. You will only need to change code if you were manually injecting\nthe instance previously.   Validator classes provide a  setTranslator()  method with which you can specify\nan instance of  Zend\\Validator\\Translator\\TranslatorInterface  which will\ntranslate the messages in case of a validation failure. The  getTranslator() \nmethod returns the translator instance.  Zend\\Mvc\\I18n\\Translator  provides an\nimplementation compatible with the validator component.  use Zend\\Mvc\\I18n\\Translator;\nuse Zend\\Validator\\StringLength;\n\n$validator = new StringLength(['min' =  8, 'max' =  12]);\n$translate = new Translator();\n// configure the translator...\n\n$validator- setTranslator($translate);  With the static  AbstractValidator::setDefaultTranslator()  method you can set a\ninstance of  Zend\\Validator\\Translator\\TranslatorInterface  which will be used\nfor all validation classes, and can be retrieved with  getDefaultTranslator() .\nThis prevents the need for setting a translator manually with each validator.  use Zend\\Mvc\\I18n\\Translator;\nuse Zend\\Validator\\AbstractValidator;\n\n$translate = new Translator();\n// configure the translator...\n\nAbstractValidator::setDefaultTranslator($translate);  Sometimes it is necessary to disable the translator within a validator. To\nachieve this you can use the  setDisableTranslator()  method, which accepts a\nboolean parameter, and  isTranslatorDisabled()  to get the set value.  use Zend\\Validator\\StringLength;\n\n$validator = new StringLength(['min' =  8, 'max' =  12]);\nif (! $validator- isTranslatorDisabled()) {\n    $validator- setDisableTranslator();\n}  It is also possible to use a translator instead of setting own messages with setMessage() . But doing so, you should keep in mind, that the translator works\nalso on messages you set your own.", 
            "title": "Translation compatibility"
        }, 
        {
            "location": "/validator-chains/", 
            "text": "Validator Chains\n\n\nOften, multiple validations should be applied to some value in a particular\norder. The following code demonstrates a way to solve the example from the\n\nintroduction\n, where a username must be between 6 and 12 alphanumeric\ncharacters:\n\n\nuse Zend\\I18n\\Validator\\Alnum;\nuse Zend\\Validator\\StringLength;\nuse Zend\\Validator\\ValidatorChain;\n\n// Create a validator chain and add validators to it\n$chain = new ValidatorChain();\n$chain-\nattach(new StringLength(['min' =\n 6, 'max' =\n 12]));\n$chain-\nattach(new Alnum());\n\n// Validate the username\nif ($validatorChain-\nisValid($username)) {\n    // username passed validation\n} else {\n    // username failed validation; print reasons\n    foreach ($validatorChain-\ngetMessages() as $message) {\n        echo \n$message\\n\n;\n    }\n}\n\n\n\n\nValidators are run in the order they were added to the \nValidatorChain\n. In the\nabove example, the username is first checked to ensure that its length is\nbetween 6 and 12 characters, and then it is checked to ensure that it contains\nonly alphanumeric characters. The second validation, for alphanumeric\ncharacters, is performed regardless of whether the first validation, for length\nbetween 6 and 12 characters, succeeds. This means that if both validations fail,\n\ngetMessages()\n will return failure messages from both validators.\n\n\nIn some cases, it makes sense to have a validator \nbreak the chain\n if its\nvalidation process fails. \nValidatorChain\n supports such use cases with the\nsecond parameter to the \nattach()\n method. By setting \n$breakChainOnFailure\n to\n\ntrue\n, if the validator fails, it will short-circuit execution of the chain,\npreventing subsequent validators from executing.  If the above example were\nwritten as follows, then the alphanumeric validation would not occur if the\nstring length validation fails:\n\n\n$chain-\nattach(new StringLength(['min' =\n 6, 'max' =\n 12], true));\n$chain-\nattach(new Alnum());\n\n\n\n\nAny object that implements \nZend\\Validator\\ValidatorInterface\n may be used in a\nvalidator chain.\n\n\nSetting Validator Chain Order\n\n\nFor each validator added to the \nValidatorChain\n, you can set a \npriority\n to\ndefine the chain order. The default value is \n1\n. Higher values indicate earlier\nexecution, while lower values execute later; use negative values to force late\nexecution.\n\n\nIn the following example, the username is first checked to ensure that its\nlength is between 7 and 9 characters, and then it is checked to ensure that its\nlength is between 3 and 5 characters.\n\n\nuse Zend\\I18n\\Validator\\Alnum;\nuse Zend\\Validator\\StringLength;\nuse Zend\\Validator\\ValidatorChain;\n\n$username = 'ABCDFE';\n\n// Create a validator chain and add validators to it\n$chain = new ValidatorChain();\n$chain-\nattach(\n    new StringLength(['min' =\n 3, 'max' =\n 5]),\n    true, // break chain on failure\n    1\n);\n$chain-\nattach(\n    new StringLength(['min' =\n 7, 'max' =\n 9]),\n    true, // break chain on failure\n    2     // higher priority!\n);\n\n// Validate the username\nif ($validatorChain-\nisValid($username)) {\n    // username passed validation\n    echo \nSuccess\n;\n} else {\n    // username failed validation; print reasons\n    foreach ($validatorChain-\ngetMessages() as $message) {\n        echo \n$message\\n\n;\n    }\n}\n\n// This first example will display: The input is less than 7 characters long", 
            "title": "Validator Chains"
        }, 
        {
            "location": "/validator-chains/#validator-chains", 
            "text": "Often, multiple validations should be applied to some value in a particular\norder. The following code demonstrates a way to solve the example from the introduction , where a username must be between 6 and 12 alphanumeric\ncharacters:  use Zend\\I18n\\Validator\\Alnum;\nuse Zend\\Validator\\StringLength;\nuse Zend\\Validator\\ValidatorChain;\n\n// Create a validator chain and add validators to it\n$chain = new ValidatorChain();\n$chain- attach(new StringLength(['min' =  6, 'max' =  12]));\n$chain- attach(new Alnum());\n\n// Validate the username\nif ($validatorChain- isValid($username)) {\n    // username passed validation\n} else {\n    // username failed validation; print reasons\n    foreach ($validatorChain- getMessages() as $message) {\n        echo  $message\\n ;\n    }\n}  Validators are run in the order they were added to the  ValidatorChain . In the\nabove example, the username is first checked to ensure that its length is\nbetween 6 and 12 characters, and then it is checked to ensure that it contains\nonly alphanumeric characters. The second validation, for alphanumeric\ncharacters, is performed regardless of whether the first validation, for length\nbetween 6 and 12 characters, succeeds. This means that if both validations fail, getMessages()  will return failure messages from both validators.  In some cases, it makes sense to have a validator  break the chain  if its\nvalidation process fails.  ValidatorChain  supports such use cases with the\nsecond parameter to the  attach()  method. By setting  $breakChainOnFailure  to true , if the validator fails, it will short-circuit execution of the chain,\npreventing subsequent validators from executing.  If the above example were\nwritten as follows, then the alphanumeric validation would not occur if the\nstring length validation fails:  $chain- attach(new StringLength(['min' =  6, 'max' =  12], true));\n$chain- attach(new Alnum());  Any object that implements  Zend\\Validator\\ValidatorInterface  may be used in a\nvalidator chain.", 
            "title": "Validator Chains"
        }, 
        {
            "location": "/validator-chains/#setting-validator-chain-order", 
            "text": "For each validator added to the  ValidatorChain , you can set a  priority  to\ndefine the chain order. The default value is  1 . Higher values indicate earlier\nexecution, while lower values execute later; use negative values to force late\nexecution.  In the following example, the username is first checked to ensure that its\nlength is between 7 and 9 characters, and then it is checked to ensure that its\nlength is between 3 and 5 characters.  use Zend\\I18n\\Validator\\Alnum;\nuse Zend\\Validator\\StringLength;\nuse Zend\\Validator\\ValidatorChain;\n\n$username = 'ABCDFE';\n\n// Create a validator chain and add validators to it\n$chain = new ValidatorChain();\n$chain- attach(\n    new StringLength(['min' =  3, 'max' =  5]),\n    true, // break chain on failure\n    1\n);\n$chain- attach(\n    new StringLength(['min' =  7, 'max' =  9]),\n    true, // break chain on failure\n    2     // higher priority!\n);\n\n// Validate the username\nif ($validatorChain- isValid($username)) {\n    // username passed validation\n    echo  Success ;\n} else {\n    // username failed validation; print reasons\n    foreach ($validatorChain- getMessages() as $message) {\n        echo  $message\\n ;\n    }\n}\n\n// This first example will display: The input is less than 7 characters long", 
            "title": "Setting Validator Chain Order"
        }, 
        {
            "location": "/writing-validators/", 
            "text": "Writing Validators\n\n\nzend-validator supplies a set of commonly needed validators, but many\napplications have needs for custom validators. The component allows this via\nimplementations of \nZend\\Validator\\ValidatorInterface\n.\n\n\nZend\\Validator\\ValidatorInterface\n defines two methods: \nisValid()\n and\n\ngetMessages()\n. An object that implements the interface may be added to a\nvalidator chain using \nZend\\Validator\\ValidatorChain::addValidator()\n. Such\nobjects may also be used with\n\nzend-inputfilter\n.\n\n\nValidators will return a boolean value from \nisValid()\n, and report information\nregarding \nwhy\n a value failed validation via \ngetMessages()\n. The\navailability of the reasons for validation failures may be valuable to an\napplication for various purposes, such as providing statistics for usability\nanalysis.\n\n\nBasic validation failure message functionality is implemented in\n\nZend\\Validator\\AbstractValidator\n, which you may extend for your custom\nvalidators.  Extending class you would implement the \nisValid()\n method logic\nand define the message variables and message templates that correspond to the\ntypes of validation failures that can occur. If a value fails your validation\ntests, then \nisValid()\n should return \nfalse\n. If the value passes your\nvalidation tests, then \nisValid()\n should return \ntrue\n.\n\n\nIn general, the \nisValid()\n method should not throw any exceptions, except where\nit is impossible to determine whether or not the input value is valid. A few\nexamples of reasonable cases for throwing an exception might be if a file cannot\nbe opened, an LDAP server could not be contacted, or a database connection is\nunavailable, where such a thing may be required for validation success or\nfailure to be determined.\n\n\nCreating a Validation Class\n\n\nThe following example demonstrates how a custom validator might be written. In\nthis case, the validator tests that a value is a floating point value.\n\n\nnamespace MyValid;\n\nuse Zend\\Validator\\AbstractValidator;\n\nclass Float extends AbstractValidator\n{\n    const FLOAT = 'float';\n\n    protected $messageTemplates = [\n        self::FLOAT =\n \n'%value%' is not a floating point value\n,\n    ];\n\n    public function isValid($value)\n    {\n        $this-\nsetValue($value);\n\n        if (! is_float($value)) {\n            $this-\nerror(self::FLOAT);\n            return false;\n        }\n\n        return true;\n    }\n}\n\n\n\n\nThe class defines a template for its single validation failure message, which\nincludes the built-in magic parameter, \n%value%\n. The call to \nsetValue()\n\nprepares the object to insert the tested value into the failure message\nautomatically, should the value fail validation. The call to \nerror()\n tracks a\nreason for validation failure. Since this class only defines one failure\nmessage, it is not necessary to provide \nerror()\n with the name of the failure\nmessage template.\n\n\nWriting a Validation Class having Dependent Conditions\n\n\nThe following example demonstrates a more complex set of validation rules:\n\n\n\n\nThe input must be numeric.\n\n\nThe input must fall within a range of boundary values.\n\n\n\n\nAn input value would fail validation for exactly one of the following reasons:\n\n\n\n\nThe input value is not numeric.\n\n\nThe input value is less than the minimum allowed value.\n\n\nThe input value is more than the maximum allowed value.\n\n\n\n\nThese validation failure reasons are then translated to definitions in the\nclass:\n\n\nnamespace MyValid;\n\nuse Zend\\Validator\\AbstractValidator;\n\nclass NumericBetween extends AbstractValidator\n{\n    const MSG_NUMERIC = 'msgNumeric';\n    const MSG_MINIMUM = 'msgMinimum';\n    const MSG_MAXIMUM = 'msgMaximum';\n\n    public $minimum = 0;\n    public $maximum = 100;\n\n    protected $messageVariables = [\n        'min' =\n 'minimum',\n        'max' =\n 'maximum',\n    ];\n\n    protected $messageTemplates = [\n        self::MSG_NUMERIC =\n \n'%value%' is not numeric\n,\n        self::MSG_MINIMUM =\n \n'%value%' must be at least '%min%'\n,\n        self::MSG_MAXIMUM =\n \n'%value%' must be no more than '%max%'\n,\n    ];\n\n    public function isValid($value)\n    {\n        $this-\nsetValue($value);\n\n        if (! is_numeric($value)) {\n            $this-\nerror(self::MSG_NUMERIC);\n            return false;\n        }\n\n        if ($value \n $this-\nminimum) {\n            $this-\nerror(self::MSG_MINIMUM);\n            return false;\n        }\n\n        if ($value \n $this-\nmaximum) {\n            $this-\nerror(self::MSG_MAXIMUM);\n            return false;\n        }\n\n        return true;\n    }\n}\n\n\n\n\nThe public properties \n$minimum\n and \n$maximum\n have been established to provide\nthe minimum and maximum boundaries, respectively, for a value to successfully\nvalidate. The class also defines two message variables that correspond to the\npublic properties and allow \nmin\n and \nmax\n to be used in message templates as\nmagic parameters, just as with \nvalue\n.\n\n\nNote that if any one of the validation checks in \nisValid()\n fails, an\nappropriate failure message is prepared, and the method immediately returns\n\nfalse\n. These validation rules are therefore sequentially dependent; that is,\nif one test should fail, there is no need to test any subsequent validation\nrules. This need not be the case, however. The following example illustrates how\nto write a class having independent validation rules, where the validation\nobject may return multiple reasons why a particular validation attempt failed.\n\n\nValidation with Independent Conditions, Multiple Reasons for Failure\n\n\nConsider writing a validation class for password strength enforcement - when a\nuser is required to choose a password that meets certain criteria for helping\nsecure user accounts. Let us assume that the password security criteria enforce\nthat the password:\n\n\n\n\nis at least 8 characters in length,\n\n\ncontains at least one uppercase letter,\n\n\ncontains at least one lowercase letter,\n\n\nand contains at least one digit character.\n\n\n\n\nThe following class implements these validation criteria:\n\n\nnamespace MyValid;\n\nuse Zend\\Validator\\AbstractValidator;\n\nclass PasswordStrength extends AbstractValidator\n{\n    const LENGTH = 'length';\n    const UPPER  = 'upper';\n    const LOWER  = 'lower';\n    const DIGIT  = 'digit';\n\n    protected $messageTemplates = [\n        self::LENGTH =\n \n'%value%' must be at least 8 characters in length\n,\n        self::UPPER  =\n \n'%value%' must contain at least one uppercase letter\n,\n        self::LOWER  =\n \n'%value%' must contain at least one lowercase letter\n,\n        self::DIGIT  =\n \n'%value%' must contain at least one digit character\n,\n    ];\n\n    public function isValid($value)\n    {\n        $this-\nsetValue($value);\n\n        $isValid = true;\n\n        if (strlen($value) \n 8) {\n            $this-\nerror(self::LENGTH);\n            $isValid = false;\n        }\n\n        if (! preg_match('/[A-Z]/', $value)) {\n            $this-\nerror(self::UPPER);\n            $isValid = false;\n        }\n\n        if (! preg_match('/[a-z]/', $value)) {\n            $this-\nerror(self::LOWER);\n            $isValid = false;\n        }\n\n        if (! preg_match('/\\d/', $value)) {\n            $this-\nerror(self::DIGIT);\n            $isValid = false;\n        }\n\n        return $isValid;\n    }\n}\n\n\n\n\nNote that the four criteria tests in \nisValid()\n do not immediately return\n\nfalse\n. This allows the validation class to provide \nall\n of the reasons that\nthe input password failed to meet the validation requirements. If, for example,\na user were to input the string \n#$%\n as a password, \nisValid()\n would cause\nall four validation failure messages to be returned by a subsequent call to\n\ngetMessages()\n.", 
            "title": "Writing Validators"
        }, 
        {
            "location": "/writing-validators/#writing-validators", 
            "text": "zend-validator supplies a set of commonly needed validators, but many\napplications have needs for custom validators. The component allows this via\nimplementations of  Zend\\Validator\\ValidatorInterface .  Zend\\Validator\\ValidatorInterface  defines two methods:  isValid()  and getMessages() . An object that implements the interface may be added to a\nvalidator chain using  Zend\\Validator\\ValidatorChain::addValidator() . Such\nobjects may also be used with zend-inputfilter .  Validators will return a boolean value from  isValid() , and report information\nregarding  why  a value failed validation via  getMessages() . The\navailability of the reasons for validation failures may be valuable to an\napplication for various purposes, such as providing statistics for usability\nanalysis.  Basic validation failure message functionality is implemented in Zend\\Validator\\AbstractValidator , which you may extend for your custom\nvalidators.  Extending class you would implement the  isValid()  method logic\nand define the message variables and message templates that correspond to the\ntypes of validation failures that can occur. If a value fails your validation\ntests, then  isValid()  should return  false . If the value passes your\nvalidation tests, then  isValid()  should return  true .  In general, the  isValid()  method should not throw any exceptions, except where\nit is impossible to determine whether or not the input value is valid. A few\nexamples of reasonable cases for throwing an exception might be if a file cannot\nbe opened, an LDAP server could not be contacted, or a database connection is\nunavailable, where such a thing may be required for validation success or\nfailure to be determined.", 
            "title": "Writing Validators"
        }, 
        {
            "location": "/writing-validators/#creating-a-validation-class", 
            "text": "The following example demonstrates how a custom validator might be written. In\nthis case, the validator tests that a value is a floating point value.  namespace MyValid;\n\nuse Zend\\Validator\\AbstractValidator;\n\nclass Float extends AbstractValidator\n{\n    const FLOAT = 'float';\n\n    protected $messageTemplates = [\n        self::FLOAT =   '%value%' is not a floating point value ,\n    ];\n\n    public function isValid($value)\n    {\n        $this- setValue($value);\n\n        if (! is_float($value)) {\n            $this- error(self::FLOAT);\n            return false;\n        }\n\n        return true;\n    }\n}  The class defines a template for its single validation failure message, which\nincludes the built-in magic parameter,  %value% . The call to  setValue() \nprepares the object to insert the tested value into the failure message\nautomatically, should the value fail validation. The call to  error()  tracks a\nreason for validation failure. Since this class only defines one failure\nmessage, it is not necessary to provide  error()  with the name of the failure\nmessage template.", 
            "title": "Creating a Validation Class"
        }, 
        {
            "location": "/writing-validators/#writing-a-validation-class-having-dependent-conditions", 
            "text": "The following example demonstrates a more complex set of validation rules:   The input must be numeric.  The input must fall within a range of boundary values.   An input value would fail validation for exactly one of the following reasons:   The input value is not numeric.  The input value is less than the minimum allowed value.  The input value is more than the maximum allowed value.   These validation failure reasons are then translated to definitions in the\nclass:  namespace MyValid;\n\nuse Zend\\Validator\\AbstractValidator;\n\nclass NumericBetween extends AbstractValidator\n{\n    const MSG_NUMERIC = 'msgNumeric';\n    const MSG_MINIMUM = 'msgMinimum';\n    const MSG_MAXIMUM = 'msgMaximum';\n\n    public $minimum = 0;\n    public $maximum = 100;\n\n    protected $messageVariables = [\n        'min' =  'minimum',\n        'max' =  'maximum',\n    ];\n\n    protected $messageTemplates = [\n        self::MSG_NUMERIC =   '%value%' is not numeric ,\n        self::MSG_MINIMUM =   '%value%' must be at least '%min%' ,\n        self::MSG_MAXIMUM =   '%value%' must be no more than '%max%' ,\n    ];\n\n    public function isValid($value)\n    {\n        $this- setValue($value);\n\n        if (! is_numeric($value)) {\n            $this- error(self::MSG_NUMERIC);\n            return false;\n        }\n\n        if ($value   $this- minimum) {\n            $this- error(self::MSG_MINIMUM);\n            return false;\n        }\n\n        if ($value   $this- maximum) {\n            $this- error(self::MSG_MAXIMUM);\n            return false;\n        }\n\n        return true;\n    }\n}  The public properties  $minimum  and  $maximum  have been established to provide\nthe minimum and maximum boundaries, respectively, for a value to successfully\nvalidate. The class also defines two message variables that correspond to the\npublic properties and allow  min  and  max  to be used in message templates as\nmagic parameters, just as with  value .  Note that if any one of the validation checks in  isValid()  fails, an\nappropriate failure message is prepared, and the method immediately returns false . These validation rules are therefore sequentially dependent; that is,\nif one test should fail, there is no need to test any subsequent validation\nrules. This need not be the case, however. The following example illustrates how\nto write a class having independent validation rules, where the validation\nobject may return multiple reasons why a particular validation attempt failed.", 
            "title": "Writing a Validation Class having Dependent Conditions"
        }, 
        {
            "location": "/writing-validators/#validation-with-independent-conditions-multiple-reasons-for-failure", 
            "text": "Consider writing a validation class for password strength enforcement - when a\nuser is required to choose a password that meets certain criteria for helping\nsecure user accounts. Let us assume that the password security criteria enforce\nthat the password:   is at least 8 characters in length,  contains at least one uppercase letter,  contains at least one lowercase letter,  and contains at least one digit character.   The following class implements these validation criteria:  namespace MyValid;\n\nuse Zend\\Validator\\AbstractValidator;\n\nclass PasswordStrength extends AbstractValidator\n{\n    const LENGTH = 'length';\n    const UPPER  = 'upper';\n    const LOWER  = 'lower';\n    const DIGIT  = 'digit';\n\n    protected $messageTemplates = [\n        self::LENGTH =   '%value%' must be at least 8 characters in length ,\n        self::UPPER  =   '%value%' must contain at least one uppercase letter ,\n        self::LOWER  =   '%value%' must contain at least one lowercase letter ,\n        self::DIGIT  =   '%value%' must contain at least one digit character ,\n    ];\n\n    public function isValid($value)\n    {\n        $this- setValue($value);\n\n        $isValid = true;\n\n        if (strlen($value)   8) {\n            $this- error(self::LENGTH);\n            $isValid = false;\n        }\n\n        if (! preg_match('/[A-Z]/', $value)) {\n            $this- error(self::UPPER);\n            $isValid = false;\n        }\n\n        if (! preg_match('/[a-z]/', $value)) {\n            $this- error(self::LOWER);\n            $isValid = false;\n        }\n\n        if (! preg_match('/\\d/', $value)) {\n            $this- error(self::DIGIT);\n            $isValid = false;\n        }\n\n        return $isValid;\n    }\n}  Note that the four criteria tests in  isValid()  do not immediately return false . This allows the validation class to provide  all  of the reasons that\nthe input password failed to meet the validation requirements. If, for example,\na user were to input the string  #$%  as a password,  isValid()  would cause\nall four validation failure messages to be returned by a subsequent call to getMessages() .", 
            "title": "Validation with Independent Conditions, Multiple Reasons for Failure"
        }, 
        {
            "location": "/messages/", 
            "text": "Validation Messages\n\n\nEach validator based on \nZend\\Validator\\ValidatorInterface\n provides one or\nmultiple messages in the case of a failed validation. You can use this\ninformation to set your own messages, or to translate existing messages which a\nvalidator could return to something different.\n\n\nValidation messages are defined as constant/template pairs, with the constant\nrepresenting a translation key. Such constants are defined per-class.  Let's\nlook into \nZend\\Validator\\GreaterThan\n for a descriptive example:\n\n\nprotected $messageTemplates = [\n    self::NOT_GREATER =\n \n'%value%' is not greater than '%min%'\n,\n];\n\n\n\n\nThe constant \nself::NOT_GREATER\n refers to the failure and is used as the\nmessage key, and the message template itself is used as the value within the\nmessage array.\n\n\nYou can retrieve all message templates from a validator by using the\n\ngetMessageTemplates()\n method. It returns the above array containing all\nmessages a validator could return in the case of a failed validation.\n\n\n$validator = new Zend\\Validator\\GreaterThan();\n$messages  = $validator-\ngetMessageTemplates();\n\n\n\n\nUsing the \nsetMessage()\n method you can set another message to be returned in\ncase of the specified failure.\n\n\nuse Zend\\Validator\\GreaterThan;\n\n$validator = new GreaterThan();\n$validator-\nsetMessage('Please enter a lower value', GreaterThan::NOT_GREATER);\n\n\n\n\nThe second parameter defines the failure which will be overridden. When you omit\nthis parameter, then the given message will be set for all possible failures of\nthis validator.\n\n\nUsing pre-translated validation messages\n\n\nzend-validator is shipped with more than 45 different validators with more than\n200 failure messages. It can be a tedious task to translate all of these\nmessages. For your convenience, pre-translated messages are provided in the\n\nzendframework/zend-i18n-resources\n\npackage:\n\n\n$ composer require zendframework/zend-i18n-resources\n\n\n\n\nTo translate all validation messages to German for example, attach a translator\nto \nZend\\Validator\\AbstractValidator\n using these resource files.\n\n\nuse Zend\\I18n\\Translator\\Resources;\nuse Zend\\Mvc\\I18n\\Translator;\nuse Zend\\Validator\\AbstractValidator;\n\n$translator = new Zend\\Mvc\\I18n\\Translator();\n$translator-\naddTranslationFilePattern(\n    'phpArray',\n    Resources::getBasePath(),\n    Resources::getPatternForValidator()\n);\n\nAbstractValidator::setDefaultTranslator($translator);\n\n\n\n\n\n\nSupported languages\n\n\nThe supported languages may not be complete. New languages will be added with\neach release. Additionally feel free to use the existing resource files to\nmake your own translations.\n\n\nYou could also use these resource files to rewrite existing translations. So\nyou are not in need to create these files manually yourself.\n\n\n\n\nLimit the size of a validation message\n\n\nSometimes it is necessary to limit the maximum size a validation message can\nhave; as an example, when your view allows a maximum size of 100 chars to be\nrendered on one line. To enable this, \nZend\\Validator\\AbstractValidator\n\nis able to automatically limit the maximum returned size of a validation\nmessage.\n\n\nTo get the actual set size use \nZend\\Validator\\AbstractValidator::getMessageLength()\n.\nIf it is \n-1\n, then the returned message will not be truncated. This is default\nbehaviour.\n\n\nTo limit the returned message size, use \nZend\\Validator\\AbstractValidator::setMessageLength()\n.\nSet it to any integer size you need. When the returned message exceeds the set\nsize, then the message will be truncated and the string \n**...**\n will be added\ninstead of the rest of the message.\n\n\nZend\\Validator\\AbstractValidator::setMessageLength(100);\n\n\n\n\n\n\nWhere is this parameter used?\n\n\nThe set message length is used for all validators, even for self defined ones,\nas long as they extend \nZend\\Validator\\AbstractValidator\n.", 
            "title": "Validation Messages"
        }, 
        {
            "location": "/messages/#validation-messages", 
            "text": "Each validator based on  Zend\\Validator\\ValidatorInterface  provides one or\nmultiple messages in the case of a failed validation. You can use this\ninformation to set your own messages, or to translate existing messages which a\nvalidator could return to something different.  Validation messages are defined as constant/template pairs, with the constant\nrepresenting a translation key. Such constants are defined per-class.  Let's\nlook into  Zend\\Validator\\GreaterThan  for a descriptive example:  protected $messageTemplates = [\n    self::NOT_GREATER =   '%value%' is not greater than '%min%' ,\n];  The constant  self::NOT_GREATER  refers to the failure and is used as the\nmessage key, and the message template itself is used as the value within the\nmessage array.  You can retrieve all message templates from a validator by using the getMessageTemplates()  method. It returns the above array containing all\nmessages a validator could return in the case of a failed validation.  $validator = new Zend\\Validator\\GreaterThan();\n$messages  = $validator- getMessageTemplates();  Using the  setMessage()  method you can set another message to be returned in\ncase of the specified failure.  use Zend\\Validator\\GreaterThan;\n\n$validator = new GreaterThan();\n$validator- setMessage('Please enter a lower value', GreaterThan::NOT_GREATER);  The second parameter defines the failure which will be overridden. When you omit\nthis parameter, then the given message will be set for all possible failures of\nthis validator.", 
            "title": "Validation Messages"
        }, 
        {
            "location": "/messages/#using-pre-translated-validation-messages", 
            "text": "zend-validator is shipped with more than 45 different validators with more than\n200 failure messages. It can be a tedious task to translate all of these\nmessages. For your convenience, pre-translated messages are provided in the zendframework/zend-i18n-resources \npackage:  $ composer require zendframework/zend-i18n-resources  To translate all validation messages to German for example, attach a translator\nto  Zend\\Validator\\AbstractValidator  using these resource files.  use Zend\\I18n\\Translator\\Resources;\nuse Zend\\Mvc\\I18n\\Translator;\nuse Zend\\Validator\\AbstractValidator;\n\n$translator = new Zend\\Mvc\\I18n\\Translator();\n$translator- addTranslationFilePattern(\n    'phpArray',\n    Resources::getBasePath(),\n    Resources::getPatternForValidator()\n);\n\nAbstractValidator::setDefaultTranslator($translator);", 
            "title": "Using pre-translated validation messages"
        }, 
        {
            "location": "/messages/#supported-languages", 
            "text": "The supported languages may not be complete. New languages will be added with\neach release. Additionally feel free to use the existing resource files to\nmake your own translations.  You could also use these resource files to rewrite existing translations. So\nyou are not in need to create these files manually yourself.", 
            "title": "Supported languages"
        }, 
        {
            "location": "/messages/#limit-the-size-of-a-validation-message", 
            "text": "Sometimes it is necessary to limit the maximum size a validation message can\nhave; as an example, when your view allows a maximum size of 100 chars to be\nrendered on one line. To enable this,  Zend\\Validator\\AbstractValidator \nis able to automatically limit the maximum returned size of a validation\nmessage.  To get the actual set size use  Zend\\Validator\\AbstractValidator::getMessageLength() .\nIf it is  -1 , then the returned message will not be truncated. This is default\nbehaviour.  To limit the returned message size, use  Zend\\Validator\\AbstractValidator::setMessageLength() .\nSet it to any integer size you need. When the returned message exceeds the set\nsize, then the message will be truncated and the string  **...**  will be added\ninstead of the rest of the message.  Zend\\Validator\\AbstractValidator::setMessageLength(100);", 
            "title": "Limit the size of a validation message"
        }, 
        {
            "location": "/messages/#where-is-this-parameter-used", 
            "text": "The set message length is used for all validators, even for self defined ones,\nas long as they extend  Zend\\Validator\\AbstractValidator .", 
            "title": "Where is this parameter used?"
        }, 
        {
            "location": "/set/", 
            "text": "Standard Validation Classes\n\n\nThe following validators come with the zend-validator distribution.\n\n\n\n\nBarcode\n\n\nBetween\n\n\nCallback\n\n\nCreditCard\n\n\nDate\n\n\nRecordExists and NoRecordExists (database)\n\n\nDigits\n\n\nEmailAddress\n\n\nFile Validation Classes\n\n\nGreaterThan\n\n\nHex\n\n\nHostname\n\n\nIban\n\n\nIdentical\n\n\nInArray\n\n\nIp\n\n\nIsbn\n\n\nIsInstanceOf\n\n\nLessThan\n\n\nNotEmpty\n\n\nRegex\n\n\nSitemap\n\n\nStep\n\n\nStringLength\n\n\nTimezone\n\n\nUri\n\n\nUuid\n\n\n\n\nAdditional validators\n\n\nSeveral other components offer validators as well:\n\n\n\n\nzend-i18n\n\n\n\n\nDeprecated Validators\n\n\nCcnum\n\n\nThe \nCcnum\n validator has been deprecated in favor of the \nCreditCard\n\nvalidator. For security reasons you should use \nCreditCard\n instead of \nCcnum\n.", 
            "title": "Standard Validation Classes"
        }, 
        {
            "location": "/set/#standard-validation-classes", 
            "text": "The following validators come with the zend-validator distribution.   Barcode  Between  Callback  CreditCard  Date  RecordExists and NoRecordExists (database)  Digits  EmailAddress  File Validation Classes  GreaterThan  Hex  Hostname  Iban  Identical  InArray  Ip  Isbn  IsInstanceOf  LessThan  NotEmpty  Regex  Sitemap  Step  StringLength  Timezone  Uri  Uuid", 
            "title": "Standard Validation Classes"
        }, 
        {
            "location": "/set/#additional-validators", 
            "text": "Several other components offer validators as well:   zend-i18n", 
            "title": "Additional validators"
        }, 
        {
            "location": "/set/#deprecated-validators", 
            "text": "", 
            "title": "Deprecated Validators"
        }, 
        {
            "location": "/set/#ccnum", 
            "text": "The  Ccnum  validator has been deprecated in favor of the  CreditCard \nvalidator. For security reasons you should use  CreditCard  instead of  Ccnum .", 
            "title": "Ccnum"
        }, 
        {
            "location": "/validators/barcode/", 
            "text": "Barcode Validator\n\n\nZend\\Validator\\Barcode\n allows you to check if a given value can be represented\nas a barcode.\n\n\nSupported barcodes\n\n\nZend\\Validator\\Barcode\n supports multiple barcode standards and can be extended\nwith proprietary barcode implementations. The following barcode standards are\nsupported:\n\n\nCODABAR\n\n\nAlso known as Code-a-bar.\n\n\nThis barcode has no length limitation. It supports only digits, and 6 special\nchars. Codabar is a self-checking barcode. This standard is very old. Common use\ncases are within airbills or photo labs where multi-part forms are used with\ndot-matrix printers.\n\n\nCODE128\n\n\nCODE128 is a high density barcode.\n\n\nThis barcode has no length limitation. It supports the first 128 ascii\ncharacters. When used with printing characters it has an checksum which is\ncalculated modulo 103. This standard is used worldwide as it supports upper and\nlowercase characters.\n\n\nCODE25\n\n\nOften called \"two of five\" or \"Code25 Industrial\".\n\n\nThis barcode has no length limitation. It supports only digits, and the last\ndigit can be an optional checksum which is calculated with modulo 10. This\nstandard is very old and nowadays not often used. Common use cases are within\nthe industry.\n\n\nCODE25INTERLEAVED\n\n\nOften called \"Code 2 of 5 Interleaved\".\n\n\nThis standard is a variant of CODE25. It has no length limitation, but it must\ncontain an even amount of characters. It supports only digits, and the last\ndigit can be an optional checksum which is calculated with modulo 10. It is used\nworldwide and common on the market.\n\n\nCODE39\n\n\nCODE39 is one of the oldest available codes.\n\n\nThis barcode has a variable length. It supports digits, upper cased alphabetical\ncharacters and 7 special characters like whitespace, point and dollar sign. It\ncan have an optional checksum which is calculated with modulo 43. This standard\nis used worldwide and common within the industry.\n\n\nCODE39EXT\n\n\nCODE39EXT is an extension of CODE39.\n\n\nThis barcode has the same properties as CODE39. Additionally it allows the usage\nof all 128 ASCII characters. This standard is used worldwide and common within\nthe industry.\n\n\nCODE93\n\n\nCODE93 is the successor of CODE39.\n\n\nThis barcode has a variable length. It supports digits, alphabetical characters\nand 7 special characters. It has an optional checksum which is calculated with\nmodulo 47 and contains 2 characters. This standard produces a denser code than\nCODE39 and is more secure.\n\n\nCODE93EXT\n\n\nCODE93EXT is an extension of CODE93.\n\n\nThis barcode has the same properties as CODE93. Additionally it allows the usage\nof all 128 ASCII characters. This standard is used worldwide and common within\nthe industry.\n\n\nEAN2\n\n\nEAN is the shortcut for \"European Article Number\".\n\n\nThese barcode must have 2 characters. It supports only digits and does not have\na checksum. This standard is mainly used as addition to EAN13 (ISBN) when\nprinted on books.\n\n\nEAN5\n\n\nEAN is the shortcut for \"European Article Number\".\n\n\nThese barcode must have 5 characters. It supports only digits and does not have\na checksum. This standard is mainly used as addition to EAN13 (ISBN) when\nprinted on books.\n\n\nEAN8\n\n\nEAN is the shortcut for \"European Article Number\".\n\n\nThese barcode can have 7 or 8 characters. It supports only digits. When it has a\nlength of 8 characters it includes a checksum. This standard is used worldwide\nbut has a very limited range. It can be found on small articles where a longer\nbarcode could not be printed.\n\n\nEAN12\n\n\nEAN is the shortcut for \"European Article Number\".\n\n\nThis barcode must have a length of 12 characters. It supports only digits, and\nthe last digit is always a checksum which is calculated with modulo 10. This\nstandard is used within the USA and common on the market. It has been superseded\nby EAN13.\n\n\nEAN13\n\n\nEAN is the shortcut for \"European Article Number\".\n\n\nThis barcode must have a length of 13 characters. It supports only digits, and\nthe last digit is always a checksum which is calculated with modulo 10. This\nstandard is used worldwide and common on the market.\n\n\nEAN14\n\n\nEAN is the shortcut for \"European Article Number\".\n\n\nThis barcode must have a length of 14 characters. It supports only digits, and\nthe last digit is always a checksum which is calculated with modulo 10. This\nstandard is used worldwide and common on the market. It is the successor for\nEAN13.\n\n\nEAN18\n\n\nEAN is the shortcut for \"European Article Number\".\n\n\nThis barcode must have a length of 18 characters. It support only digits. The\nlast digit is always a checksum digit which is calculated with modulo 10. This\ncode is often used for the identification of shipping containers.\n\n\nGTIN12\n\n\nGTIN is the shortcut for \"Global Trade Item Number\".\n\n\nThis barcode uses the same standard as EAN12 and is its successor. It's commonly\nused within the USA.\n\n\nGTIN13\n\n\nGTIN is the shortcut for \"Global Trade Item Number\".\n\n\nThis barcode uses the same standard as EAN13 and is its successor. It is used\nworldwide by industry.\n\n\nGTIN14\n\n\nGTIN is the shortcut for \"Global Trade Item Number\".\n\n\nThis barcode uses the same standard as EAN14 and is its successor. It is used\nworldwide and common on the market.\n\n\nIDENTCODE\n\n\nIdentcode is used by Deutsche Post and DHL. It's an specialized implementation of Code25.\n\n\nThis barcode must have a length of 12 characters. It supports only digits, and\nthe last digit is always a checksum which is calculated with modulo 10. This\nstandard is mainly used by the companies DP and DHL.\n\n\nINTELLIGENTMAIL\n\n\nIntelligent Mail is a postal barcode.\n\n\nThis barcode can have a length of 20, 25, 29 or 31 characters. It supports only\ndigits, and contains no checksum. This standard is the successor of PLANET and\nPOSTNET. It is mainly used by the United States Postal Services.\n\n\nISSN\n\n\nISSN is the abbreviation for International Standard Serial Number.\n\n\nThis barcode can have a length of 8 or 13 characters. It supports only digits,\nand the last digit must be a checksum digit which is calculated with modulo 11.\nIt is used worldwide for printed publications.\n\n\nITF14\n\n\nITF14 is the GS1 implementation of an Interleaved Two of Five bar code.\n\n\nThis barcode is a special variant of Interleaved 2 of 5. It must have a length\nof 14 characters and is based on GTIN14. It supports only digits, and the last\ndigit must be a checksum digit which is calculated with modulo 10. It is used\nworldwide and common within the market.\n\n\nLEITCODE\n\n\nLeitcode is used by Deutsche Post and DHL. It's an specialized implementation of Code25.\n\n\nThis barcode must have a length of 14 characters. It supports only digits, and\nthe last digit is always a checksum which is calculated with modulo 10. This\nstandard is mainly used by the companies DP and DHL.\n\n\nPLANET\n\n\nPlanet is the abbreviation for Postal Alpha Numeric Encoding Technique.\n\n\nThis barcode can have a length of 12 or 14 characters. It supports only digits,\nand the last digit is always a checksum. This standard is mainly used by the\nUnited States Postal Services.\n\n\nPOSTNET\n\n\nPostnet is used by the US Postal Service.\n\n\nThis barcode can have a length of 6, 7, 10 or 12 characters. It supports only\ndigits, and the last digit is always a checksum. This standard is mainly used by\nthe United States Postal Services.\n\n\nROYALMAIL\n\n\nRoyalmail is used by Royal Mail.\n\n\nThis barcode has no defined length. It supports digits, uppercase letters, and\nthe last digit is always a checksum. This standard is mainly used by Royal Mail\nfor their Cleanmail Service. It is also called RM4SCC.\n\n\nSSCC\n\n\nSSCC is the shortcut for \"Serial Shipping Container Code\".\n\n\nThis barcode is a variant of EAN barcode. It must have a length of 18 characters\nand supports only digits. The last digit must be a checksum digit which is\ncalculated with modulo 10. It is commonly used by the transport industry.\n\n\nUPCA\n\n\nUPC is the shortcut for \"Universal Product Code\".\n\n\nThis barcode preceded EAN13. It must have a length of 12 characters and supports\nonly digits. The last digit must be a checksum digit which is calculated with\nmodulo 10. It is commonly used within the USA.\n\n\nUPCE\n\n\nUPCE is the short variant from UPCA.\n\n\nThis barcode is a smaller variant of UPCA. It can have a length of 6, 7 or 8\ncharacters and supports only digits. When the barcode is 8 chars long it\nincludes a checksum which is calculated with modulo 10. It is commonly used with\nsmall products where a UPCA barcode would not fit.\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\Barcode\n:\n\n\n\n\nadapter\n: Sets the barcode adapter which will be used. Supported are all\n  above noted adapters. When using a self defined adapter, then you have to set\n  the complete class name.\n\n\nchecksum\n: \nTRUE\n when the barcode should contain a checksum. The default\n  value depends on the used adapter. Note that some adapters don't allow to set\n  this option.\n\n\noptions\n: Defines optional options for a self written adapters.\n\n\n\n\nBasic usage\n\n\nTo validate if a given string is a barcode you must know its type. See the\nfollowing example for an EAN13 barcode:\n\n\n$valid = new Zend\\Validator\\Barcode('EAN13');\nif ($valid-\nisValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}\n\n\n\n\nOptional checksum\n\n\nSome barcodes can be provided with an optional checksum. These barcodes would be\nvalid even without checksum. Still, when you provide a checksum, then you should\nalso validate it. By default, these barcode types perform no checksum\nvalidation. By using the \nchecksum\n option you can define if the checksum will\nbe validated or ignored.\n\n\n$valid = new Zend\\Validator\\Barcode([\n    'adapter'  =\n 'EAN13',\n    'checksum' =\n false,\n]);\nif ($valid-\nisValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}\n\n\n\n\n\n\nReduced security by disabling checksum validation\n\n\nBy switching off checksum validation you will also reduce the security of the\nused barcodes. Additionally you should note that you can also turn off the\nchecksum validation for those barcode types which must contain a checksum\nvalue. Barcodes which would not be valid could then be returned as valid even\nif they are not.\n\n\n\n\nWriting custom adapters\n\n\nYou may write custom barcode validators for usage with \nZend\\Validator\\Barcode\n;\nthis is often necessary when dealing with proprietary barcode types. To write\nyour own barcode validator, you need the following information.\n\n\n\n\nLength\n: The length your barcode must have. It can have one of the following\n  values:\n\n\nInteger\n: A value greater 0, which means that the barcode must have this\n    length.\n\n\n-1\n: There is no limitation for the length of this barcode.\n\n\n\"even\"\n: The length of this barcode must have a even amount of digits.\n\n\n\"odd\"\n: The length of this barcode must have a odd amount of digits.\n\n\narray\n: An array of integer values. The length of this barcode must have\n    one of the set array values.\n\n\nCharacters\n: A string which contains all allowed characters for this barcode.\n  Also the integer value 128 is allowed, which means the first 128 characters of\n  the ASCII table.\n\n\nChecksum\n: A string which will be used as callback for a method which does\n  the checksum validation.\n\n\n\n\nYour custom barcode validator must extend \nZend\\Validator\\Barcode\\AbstractAdapter\n\nor implement \nZend\\Validator\\Barcode\\AdapterInterface\n.\n\n\nAs an example, let's create a validator that expects an even number of\ncharacters that include all digits and the letters 'ABCDE', and which requires a\nchecksum.\n\n\nnamespace My\\Barcode;\n\nuse Zend\\Validator\\Barcode;\nuse Zend\\Validator\\Barcode\\AbstractAdapter;\n\nclass MyBar extends AbstractAdapter\n{\n    protected $length     = 'even';\n    protected $characters = '0123456789ABCDE';\n    protected $checksum   = 'mod66';\n\n    protected function mod66($barcode)\n    {\n        // do some validations and return a boolean\n    }\n}\n\n$valid = Barcode(MyBar::class);\nif ($valid-\nisValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}", 
            "title": "Barcode"
        }, 
        {
            "location": "/validators/barcode/#barcode-validator", 
            "text": "Zend\\Validator\\Barcode  allows you to check if a given value can be represented\nas a barcode.", 
            "title": "Barcode Validator"
        }, 
        {
            "location": "/validators/barcode/#supported-barcodes", 
            "text": "Zend\\Validator\\Barcode  supports multiple barcode standards and can be extended\nwith proprietary barcode implementations. The following barcode standards are\nsupported:", 
            "title": "Supported barcodes"
        }, 
        {
            "location": "/validators/barcode/#codabar", 
            "text": "Also known as Code-a-bar.  This barcode has no length limitation. It supports only digits, and 6 special\nchars. Codabar is a self-checking barcode. This standard is very old. Common use\ncases are within airbills or photo labs where multi-part forms are used with\ndot-matrix printers.", 
            "title": "CODABAR"
        }, 
        {
            "location": "/validators/barcode/#code128", 
            "text": "CODE128 is a high density barcode.  This barcode has no length limitation. It supports the first 128 ascii\ncharacters. When used with printing characters it has an checksum which is\ncalculated modulo 103. This standard is used worldwide as it supports upper and\nlowercase characters.", 
            "title": "CODE128"
        }, 
        {
            "location": "/validators/barcode/#code25", 
            "text": "Often called \"two of five\" or \"Code25 Industrial\".  This barcode has no length limitation. It supports only digits, and the last\ndigit can be an optional checksum which is calculated with modulo 10. This\nstandard is very old and nowadays not often used. Common use cases are within\nthe industry.", 
            "title": "CODE25"
        }, 
        {
            "location": "/validators/barcode/#code25interleaved", 
            "text": "Often called \"Code 2 of 5 Interleaved\".  This standard is a variant of CODE25. It has no length limitation, but it must\ncontain an even amount of characters. It supports only digits, and the last\ndigit can be an optional checksum which is calculated with modulo 10. It is used\nworldwide and common on the market.", 
            "title": "CODE25INTERLEAVED"
        }, 
        {
            "location": "/validators/barcode/#code39", 
            "text": "CODE39 is one of the oldest available codes.  This barcode has a variable length. It supports digits, upper cased alphabetical\ncharacters and 7 special characters like whitespace, point and dollar sign. It\ncan have an optional checksum which is calculated with modulo 43. This standard\nis used worldwide and common within the industry.", 
            "title": "CODE39"
        }, 
        {
            "location": "/validators/barcode/#code39ext", 
            "text": "CODE39EXT is an extension of CODE39.  This barcode has the same properties as CODE39. Additionally it allows the usage\nof all 128 ASCII characters. This standard is used worldwide and common within\nthe industry.", 
            "title": "CODE39EXT"
        }, 
        {
            "location": "/validators/barcode/#code93", 
            "text": "CODE93 is the successor of CODE39.  This barcode has a variable length. It supports digits, alphabetical characters\nand 7 special characters. It has an optional checksum which is calculated with\nmodulo 47 and contains 2 characters. This standard produces a denser code than\nCODE39 and is more secure.", 
            "title": "CODE93"
        }, 
        {
            "location": "/validators/barcode/#code93ext", 
            "text": "CODE93EXT is an extension of CODE93.  This barcode has the same properties as CODE93. Additionally it allows the usage\nof all 128 ASCII characters. This standard is used worldwide and common within\nthe industry.", 
            "title": "CODE93EXT"
        }, 
        {
            "location": "/validators/barcode/#ean2", 
            "text": "EAN is the shortcut for \"European Article Number\".  These barcode must have 2 characters. It supports only digits and does not have\na checksum. This standard is mainly used as addition to EAN13 (ISBN) when\nprinted on books.", 
            "title": "EAN2"
        }, 
        {
            "location": "/validators/barcode/#ean5", 
            "text": "EAN is the shortcut for \"European Article Number\".  These barcode must have 5 characters. It supports only digits and does not have\na checksum. This standard is mainly used as addition to EAN13 (ISBN) when\nprinted on books.", 
            "title": "EAN5"
        }, 
        {
            "location": "/validators/barcode/#ean8", 
            "text": "EAN is the shortcut for \"European Article Number\".  These barcode can have 7 or 8 characters. It supports only digits. When it has a\nlength of 8 characters it includes a checksum. This standard is used worldwide\nbut has a very limited range. It can be found on small articles where a longer\nbarcode could not be printed.", 
            "title": "EAN8"
        }, 
        {
            "location": "/validators/barcode/#ean12", 
            "text": "EAN is the shortcut for \"European Article Number\".  This barcode must have a length of 12 characters. It supports only digits, and\nthe last digit is always a checksum which is calculated with modulo 10. This\nstandard is used within the USA and common on the market. It has been superseded\nby EAN13.", 
            "title": "EAN12"
        }, 
        {
            "location": "/validators/barcode/#ean13", 
            "text": "EAN is the shortcut for \"European Article Number\".  This barcode must have a length of 13 characters. It supports only digits, and\nthe last digit is always a checksum which is calculated with modulo 10. This\nstandard is used worldwide and common on the market.", 
            "title": "EAN13"
        }, 
        {
            "location": "/validators/barcode/#ean14", 
            "text": "EAN is the shortcut for \"European Article Number\".  This barcode must have a length of 14 characters. It supports only digits, and\nthe last digit is always a checksum which is calculated with modulo 10. This\nstandard is used worldwide and common on the market. It is the successor for\nEAN13.", 
            "title": "EAN14"
        }, 
        {
            "location": "/validators/barcode/#ean18", 
            "text": "EAN is the shortcut for \"European Article Number\".  This barcode must have a length of 18 characters. It support only digits. The\nlast digit is always a checksum digit which is calculated with modulo 10. This\ncode is often used for the identification of shipping containers.", 
            "title": "EAN18"
        }, 
        {
            "location": "/validators/barcode/#gtin12", 
            "text": "GTIN is the shortcut for \"Global Trade Item Number\".  This barcode uses the same standard as EAN12 and is its successor. It's commonly\nused within the USA.", 
            "title": "GTIN12"
        }, 
        {
            "location": "/validators/barcode/#gtin13", 
            "text": "GTIN is the shortcut for \"Global Trade Item Number\".  This barcode uses the same standard as EAN13 and is its successor. It is used\nworldwide by industry.", 
            "title": "GTIN13"
        }, 
        {
            "location": "/validators/barcode/#gtin14", 
            "text": "GTIN is the shortcut for \"Global Trade Item Number\".  This barcode uses the same standard as EAN14 and is its successor. It is used\nworldwide and common on the market.", 
            "title": "GTIN14"
        }, 
        {
            "location": "/validators/barcode/#identcode", 
            "text": "Identcode is used by Deutsche Post and DHL. It's an specialized implementation of Code25.  This barcode must have a length of 12 characters. It supports only digits, and\nthe last digit is always a checksum which is calculated with modulo 10. This\nstandard is mainly used by the companies DP and DHL.", 
            "title": "IDENTCODE"
        }, 
        {
            "location": "/validators/barcode/#intelligentmail", 
            "text": "Intelligent Mail is a postal barcode.  This barcode can have a length of 20, 25, 29 or 31 characters. It supports only\ndigits, and contains no checksum. This standard is the successor of PLANET and\nPOSTNET. It is mainly used by the United States Postal Services.", 
            "title": "INTELLIGENTMAIL"
        }, 
        {
            "location": "/validators/barcode/#issn", 
            "text": "ISSN is the abbreviation for International Standard Serial Number.  This barcode can have a length of 8 or 13 characters. It supports only digits,\nand the last digit must be a checksum digit which is calculated with modulo 11.\nIt is used worldwide for printed publications.", 
            "title": "ISSN"
        }, 
        {
            "location": "/validators/barcode/#itf14", 
            "text": "ITF14 is the GS1 implementation of an Interleaved Two of Five bar code.  This barcode is a special variant of Interleaved 2 of 5. It must have a length\nof 14 characters and is based on GTIN14. It supports only digits, and the last\ndigit must be a checksum digit which is calculated with modulo 10. It is used\nworldwide and common within the market.", 
            "title": "ITF14"
        }, 
        {
            "location": "/validators/barcode/#leitcode", 
            "text": "Leitcode is used by Deutsche Post and DHL. It's an specialized implementation of Code25.  This barcode must have a length of 14 characters. It supports only digits, and\nthe last digit is always a checksum which is calculated with modulo 10. This\nstandard is mainly used by the companies DP and DHL.", 
            "title": "LEITCODE"
        }, 
        {
            "location": "/validators/barcode/#planet", 
            "text": "Planet is the abbreviation for Postal Alpha Numeric Encoding Technique.  This barcode can have a length of 12 or 14 characters. It supports only digits,\nand the last digit is always a checksum. This standard is mainly used by the\nUnited States Postal Services.", 
            "title": "PLANET"
        }, 
        {
            "location": "/validators/barcode/#postnet", 
            "text": "Postnet is used by the US Postal Service.  This barcode can have a length of 6, 7, 10 or 12 characters. It supports only\ndigits, and the last digit is always a checksum. This standard is mainly used by\nthe United States Postal Services.", 
            "title": "POSTNET"
        }, 
        {
            "location": "/validators/barcode/#royalmail", 
            "text": "Royalmail is used by Royal Mail.  This barcode has no defined length. It supports digits, uppercase letters, and\nthe last digit is always a checksum. This standard is mainly used by Royal Mail\nfor their Cleanmail Service. It is also called RM4SCC.", 
            "title": "ROYALMAIL"
        }, 
        {
            "location": "/validators/barcode/#sscc", 
            "text": "SSCC is the shortcut for \"Serial Shipping Container Code\".  This barcode is a variant of EAN barcode. It must have a length of 18 characters\nand supports only digits. The last digit must be a checksum digit which is\ncalculated with modulo 10. It is commonly used by the transport industry.", 
            "title": "SSCC"
        }, 
        {
            "location": "/validators/barcode/#upca", 
            "text": "UPC is the shortcut for \"Universal Product Code\".  This barcode preceded EAN13. It must have a length of 12 characters and supports\nonly digits. The last digit must be a checksum digit which is calculated with\nmodulo 10. It is commonly used within the USA.", 
            "title": "UPCA"
        }, 
        {
            "location": "/validators/barcode/#upce", 
            "text": "UPCE is the short variant from UPCA.  This barcode is a smaller variant of UPCA. It can have a length of 6, 7 or 8\ncharacters and supports only digits. When the barcode is 8 chars long it\nincludes a checksum which is calculated with modulo 10. It is commonly used with\nsmall products where a UPCA barcode would not fit.", 
            "title": "UPCE"
        }, 
        {
            "location": "/validators/barcode/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\Barcode :   adapter : Sets the barcode adapter which will be used. Supported are all\n  above noted adapters. When using a self defined adapter, then you have to set\n  the complete class name.  checksum :  TRUE  when the barcode should contain a checksum. The default\n  value depends on the used adapter. Note that some adapters don't allow to set\n  this option.  options : Defines optional options for a self written adapters.", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/barcode/#basic-usage", 
            "text": "To validate if a given string is a barcode you must know its type. See the\nfollowing example for an EAN13 barcode:  $valid = new Zend\\Validator\\Barcode('EAN13');\nif ($valid- isValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}", 
            "title": "Basic usage"
        }, 
        {
            "location": "/validators/barcode/#optional-checksum", 
            "text": "Some barcodes can be provided with an optional checksum. These barcodes would be\nvalid even without checksum. Still, when you provide a checksum, then you should\nalso validate it. By default, these barcode types perform no checksum\nvalidation. By using the  checksum  option you can define if the checksum will\nbe validated or ignored.  $valid = new Zend\\Validator\\Barcode([\n    'adapter'  =  'EAN13',\n    'checksum' =  false,\n]);\nif ($valid- isValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}", 
            "title": "Optional checksum"
        }, 
        {
            "location": "/validators/barcode/#reduced-security-by-disabling-checksum-validation", 
            "text": "By switching off checksum validation you will also reduce the security of the\nused barcodes. Additionally you should note that you can also turn off the\nchecksum validation for those barcode types which must contain a checksum\nvalue. Barcodes which would not be valid could then be returned as valid even\nif they are not.", 
            "title": "Reduced security by disabling checksum validation"
        }, 
        {
            "location": "/validators/barcode/#writing-custom-adapters", 
            "text": "You may write custom barcode validators for usage with  Zend\\Validator\\Barcode ;\nthis is often necessary when dealing with proprietary barcode types. To write\nyour own barcode validator, you need the following information.   Length : The length your barcode must have. It can have one of the following\n  values:  Integer : A value greater 0, which means that the barcode must have this\n    length.  -1 : There is no limitation for the length of this barcode.  \"even\" : The length of this barcode must have a even amount of digits.  \"odd\" : The length of this barcode must have a odd amount of digits.  array : An array of integer values. The length of this barcode must have\n    one of the set array values.  Characters : A string which contains all allowed characters for this barcode.\n  Also the integer value 128 is allowed, which means the first 128 characters of\n  the ASCII table.  Checksum : A string which will be used as callback for a method which does\n  the checksum validation.   Your custom barcode validator must extend  Zend\\Validator\\Barcode\\AbstractAdapter \nor implement  Zend\\Validator\\Barcode\\AdapterInterface .  As an example, let's create a validator that expects an even number of\ncharacters that include all digits and the letters 'ABCDE', and which requires a\nchecksum.  namespace My\\Barcode;\n\nuse Zend\\Validator\\Barcode;\nuse Zend\\Validator\\Barcode\\AbstractAdapter;\n\nclass MyBar extends AbstractAdapter\n{\n    protected $length     = 'even';\n    protected $characters = '0123456789ABCDE';\n    protected $checksum   = 'mod66';\n\n    protected function mod66($barcode)\n    {\n        // do some validations and return a boolean\n    }\n}\n\n$valid = Barcode(MyBar::class);\nif ($valid- isValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}", 
            "title": "Writing custom adapters"
        }, 
        {
            "location": "/validators/between/", 
            "text": "Between Validator\n\n\nZend\\Validator\\Between\n allows you to validate if a given value is between two\nother values.\n\n\n\n\nOnly supports number validation\n\n\nZend\\Validator\\Between\n supports only the validation of numbers. Strings or\ndates can not be validated with this validator.\n\n\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\Between\n:\n\n\n\n\ninclusive\n: Defines if the validation is inclusive of the minimum and maximum\n  border values, or exclusive. It defaults to \ntrue\n.\n\n\nmax\n: Sets the maximum border for the validation.\n\n\nmin\n: Sets the minimum border for the validation.\n\n\n\n\nDefault behaviour\n\n\nPer default, this validator checks if a value is between \nmin\n and \nmax\n where\nboth border values are allowed as value.\n\n\n$valid  = new Zend\\Validator\\Between(['min' =\n 0, 'max' =\n 10]);\n$value  = 10;\n$result = $valid-\nisValid($value);\n// returns true\n\n\n\n\nIn the above example, the result is \ntrue\n due to the reason that the default\nsearch is inclusive of the border values. This means in our case that any value\nfrom '0' to '10' is allowed; values like '-1' and '11' will return \nfalse\n.\n\n\nExcluding border values\n\n\nSometimes it is useful to validate a value by excluding the border values. See\nthe following example:\n\n\n$valid  = new Zend\\Validator\\Between([\n    'min' =\n 0,\n    'max' =\n 10,\n    'inclusive' =\n false,\n]);\n$value  = 10;\n$result = $valid-\nisValid($value);\n// returns false\n\n\n\n\nThe example above is almost identical to our first example, but we now exclue\nthe border values; as such, the values '0' and '10' are no longer allowed and\nwill return \nfalse\n.", 
            "title": "Between"
        }, 
        {
            "location": "/validators/between/#between-validator", 
            "text": "Zend\\Validator\\Between  allows you to validate if a given value is between two\nother values.", 
            "title": "Between Validator"
        }, 
        {
            "location": "/validators/between/#only-supports-number-validation", 
            "text": "Zend\\Validator\\Between  supports only the validation of numbers. Strings or\ndates can not be validated with this validator.", 
            "title": "Only supports number validation"
        }, 
        {
            "location": "/validators/between/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\Between :   inclusive : Defines if the validation is inclusive of the minimum and maximum\n  border values, or exclusive. It defaults to  true .  max : Sets the maximum border for the validation.  min : Sets the minimum border for the validation.", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/between/#default-behaviour", 
            "text": "Per default, this validator checks if a value is between  min  and  max  where\nboth border values are allowed as value.  $valid  = new Zend\\Validator\\Between(['min' =  0, 'max' =  10]);\n$value  = 10;\n$result = $valid- isValid($value);\n// returns true  In the above example, the result is  true  due to the reason that the default\nsearch is inclusive of the border values. This means in our case that any value\nfrom '0' to '10' is allowed; values like '-1' and '11' will return  false .", 
            "title": "Default behaviour"
        }, 
        {
            "location": "/validators/between/#excluding-border-values", 
            "text": "Sometimes it is useful to validate a value by excluding the border values. See\nthe following example:  $valid  = new Zend\\Validator\\Between([\n    'min' =  0,\n    'max' =  10,\n    'inclusive' =  false,\n]);\n$value  = 10;\n$result = $valid- isValid($value);\n// returns false  The example above is almost identical to our first example, but we now exclue\nthe border values; as such, the values '0' and '10' are no longer allowed and\nwill return  false .", 
            "title": "Excluding border values"
        }, 
        {
            "location": "/validators/callback/", 
            "text": "Callback Validator\n\n\nZend\\Validator\\Callback\n allows you to provide a callback with which to\nvalidate a given value.\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\Callback\n:\n\n\n\n\ncallback\n: Sets the callback which will be called for the validation.\n\n\noptions\n: Sets the additional options which will be given to the validator\n  and/or callback.\n\n\n\n\nBasic usage\n\n\nThe simplest use case is to pass a function as a callback. Consider the\nfollowing function:\n\n\nfunction myMethod($value)\n{\n    // some validation\n    return true;\n}\n\n\n\n\nTo use it within \nZend\\Validator\\Callback\n, pass it to the constructor\n\n\n$valid = new Zend\\Validator\\Callback('myMethod');\nif ($valid-\nisValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}\n\n\n\n\nUsage with closures\n\n\nThe \nCallback\n validator supports any PHP callable, including PHP\n\nclosures\n.\n\n\n$valid = new Zend\\Validator\\Callback(function($value) {\n    // some validation\n    return true;\n});\n\nif ($valid-\nisValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}\n\n\n\n\nUsage with class-based callbacks\n\n\nOf course it's also possible to use a class method as callback. Consider the\nfollowing class definition:\n\n\nclass MyClass\n{\n    public function myMethod($value)\n    {\n        // some validation\n        return true;\n    }\n}\n\n\n\n\nTo use it with the \nCallback\n validator, pass a callable using an instance of\nthe class:\n\n\n$valid = new Zend\\Validator\\Callback([new MyClass, 'myMethod']);\nif ($valid-\nisValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}\n\n\n\n\nYou may also define a static method as a callback. Consider the following class\ndefinition and validator usage:\n\n\nclass MyClass\n{\n    public static function test($value)\n    {\n        // some validation\n        return true;\n    }\n}\n\n$valid = new Zend\\Validator\\Callback(MyClass::class, 'test']);\nif ($valid-\nisValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}\n\n\n\n\nFinally, you may define the magic method \n__invoke()\n in your class. If you do\nso, you can provide a class instance itself as the callback:\n\n\nclass MyClass\n{\n    public function __invoke($value)\n    {\n        // some validation\n        return true;\n    }\n}\n\n$valid = new Zend\\Validator\\Callback(new MyClass());\nif ($valid-\nisValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}\n\n\n\n\nAdding options\n\n\nZend\\Validator\\Callback\n also allows the usage of options which are provided as\nadditional arguments to the callback.\n\n\nConsider the following class and method definition:\n\n\nclass MyClass\n{\n    public static function myMethod($value, $option)\n    {\n        // some validation\n        return true;\n    }\n\n    /**\n     * Or, to use with contextual validation\n     */\n    public static function myMethod($value, $context, $option)\n    {\n        // some validation\n        return true;\n    }\n\n}\n\n\n\n\nThere are two ways to inform the validator of additional options: pass them in\nthe constructor, or pass them to the \nsetOptions()\n method.\n\n\nTo pass them to the constructor, you would need to pass an array containing two\nkeys, \ncallback\n and \ncallbackOptions\n:\n\n\n$valid = new Zend\\Validator\\Callback([\n    'callback'        =\n [MyClass::class, 'myMethod'],\n    'callbackOptions' =\n $options,\n]);\n\nif ($valid-\nisValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}\n\n\n\n\nOtherwise, you may pass them to the validator after instantiation:\n\n\n$valid = new Zend\\Validator\\Callback([MyClass::class, 'myMethod']);\n$valid-\nsetOptions($options);\n\nif ($valid-\nisValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}\n\n\n\n\nWhen there are additional values given to \nisValid()\n, then these values will be\npassed as an additional argument:\n\n\n$valid = new Zend\\Validator\\Callback([MyClass::class, 'myMethod']);\n$valid-\nsetOptions($options);\n\nif ($valid-\nisValid($input, $context)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}\n\n\n\n\nWhen making the call to the callback, the value to be validated will always be\npassed as the first argument to the callback followed by all other values given\nto \nisValid()\n; all other options will follow it. The amount and type of options\nwhich can be used is not limited.", 
            "title": "Callback"
        }, 
        {
            "location": "/validators/callback/#callback-validator", 
            "text": "Zend\\Validator\\Callback  allows you to provide a callback with which to\nvalidate a given value.", 
            "title": "Callback Validator"
        }, 
        {
            "location": "/validators/callback/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\Callback :   callback : Sets the callback which will be called for the validation.  options : Sets the additional options which will be given to the validator\n  and/or callback.", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/callback/#basic-usage", 
            "text": "The simplest use case is to pass a function as a callback. Consider the\nfollowing function:  function myMethod($value)\n{\n    // some validation\n    return true;\n}  To use it within  Zend\\Validator\\Callback , pass it to the constructor  $valid = new Zend\\Validator\\Callback('myMethod');\nif ($valid- isValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}", 
            "title": "Basic usage"
        }, 
        {
            "location": "/validators/callback/#usage-with-closures", 
            "text": "The  Callback  validator supports any PHP callable, including PHP closures .  $valid = new Zend\\Validator\\Callback(function($value) {\n    // some validation\n    return true;\n});\n\nif ($valid- isValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}", 
            "title": "Usage with closures"
        }, 
        {
            "location": "/validators/callback/#usage-with-class-based-callbacks", 
            "text": "Of course it's also possible to use a class method as callback. Consider the\nfollowing class definition:  class MyClass\n{\n    public function myMethod($value)\n    {\n        // some validation\n        return true;\n    }\n}  To use it with the  Callback  validator, pass a callable using an instance of\nthe class:  $valid = new Zend\\Validator\\Callback([new MyClass, 'myMethod']);\nif ($valid- isValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}  You may also define a static method as a callback. Consider the following class\ndefinition and validator usage:  class MyClass\n{\n    public static function test($value)\n    {\n        // some validation\n        return true;\n    }\n}\n\n$valid = new Zend\\Validator\\Callback(MyClass::class, 'test']);\nif ($valid- isValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}  Finally, you may define the magic method  __invoke()  in your class. If you do\nso, you can provide a class instance itself as the callback:  class MyClass\n{\n    public function __invoke($value)\n    {\n        // some validation\n        return true;\n    }\n}\n\n$valid = new Zend\\Validator\\Callback(new MyClass());\nif ($valid- isValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}", 
            "title": "Usage with class-based callbacks"
        }, 
        {
            "location": "/validators/callback/#adding-options", 
            "text": "Zend\\Validator\\Callback  also allows the usage of options which are provided as\nadditional arguments to the callback.  Consider the following class and method definition:  class MyClass\n{\n    public static function myMethod($value, $option)\n    {\n        // some validation\n        return true;\n    }\n\n    /**\n     * Or, to use with contextual validation\n     */\n    public static function myMethod($value, $context, $option)\n    {\n        // some validation\n        return true;\n    }\n\n}  There are two ways to inform the validator of additional options: pass them in\nthe constructor, or pass them to the  setOptions()  method.  To pass them to the constructor, you would need to pass an array containing two\nkeys,  callback  and  callbackOptions :  $valid = new Zend\\Validator\\Callback([\n    'callback'        =  [MyClass::class, 'myMethod'],\n    'callbackOptions' =  $options,\n]);\n\nif ($valid- isValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}  Otherwise, you may pass them to the validator after instantiation:  $valid = new Zend\\Validator\\Callback([MyClass::class, 'myMethod']);\n$valid- setOptions($options);\n\nif ($valid- isValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}  When there are additional values given to  isValid() , then these values will be\npassed as an additional argument:  $valid = new Zend\\Validator\\Callback([MyClass::class, 'myMethod']);\n$valid- setOptions($options);\n\nif ($valid- isValid($input, $context)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}  When making the call to the callback, the value to be validated will always be\npassed as the first argument to the callback followed by all other values given\nto  isValid() ; all other options will follow it. The amount and type of options\nwhich can be used is not limited.", 
            "title": "Adding options"
        }, 
        {
            "location": "/validators/credit-card/", 
            "text": "CreditCard Validator\n\n\nZend\\Validator\\CreditCard\n allows you to validate if a given value could be a\ncredit card number.\n\n\nA credit card contains several items of metadata, including a hologram, account\nnumber, logo, expiration date, security code, and the card holder name. The\nalgorithms for verifying the combination of metadata are only known to the\nissuing company, and should be verified with them for purposes of payment.\nHowever, it's often useful to know whether or not a given number actually falls\nwithin the ranges of possible numbers \nprior\n to performing such verification,\nand, as such, \nZend\\Validator\\CreditCard\n verifies that the credit card number\nprovided is well-formed.\n\n\nFor those cases where you have a service that can perform comprehensive\nverification, \nZend\\Validator\\CreditCard\n also provides the ability to attach a\nservice callback to trigger once the credit card number has been deemed valid;\nthis callback will then be triggered, and its return value will determine\noverall validity.\n\n\nThe following issuing institutes are accepted:\n\n\n\n\nAmerican Express\n\n\nChina UnionPay\n\n\nDiners Club Card Blanche\n\n\nDiners Club International\n\n\nDiners Club US and Canada\n\n\nDiscover Card\n\n\nJCB\n\n\nLaser\n\n\nMaestro\n\n\nMasterCard\n\n\nSolo\n\n\nVisa\n\n\nVisa Electron\n\n\nRussia Mir\n\n\n\n\n\n\nInvalid institutes\n\n\nThe institutes \nBankcard\n and \nDiners Club enRoute\n no longer exist, and\nare treated as invalid.\n\n\nSwitch\n has been rebranded to \nVisa\n and is therefore also treated as\ninvalid.\n\n\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\CreditCard\n:\n\n\n\n\nservice\n: A callback to an online service which will additionally be used for\n  the validation.\n\n\ntype\n: The type of credit card which will be validated. See the below list of\n  institutes for details.\n\n\n\n\nBasic usage\n\n\nThere are several credit card institutes which can be validated by\n\nZend\\Validator\\CreditCard\n. Per default, all known institutes will be accepted.\nSee the following example:\n\n\n$valid = new Zend\\Validator\\CreditCard();\nif ($valid-\nisValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}\n\n\n\n\nThe above example would validate against all known credit card institutes.\n\n\nAccepting only specific credit cards\n\n\nSometimes it is necessary to accept only specific credit card institutes instead\nof all; e.g., when you have a webshop which accepts only Visa and American\nExpress cards. \nZend\\Validator\\CreditCard\n allows you to do exactly this by\nlimiting it to exactly these institutes.\n\n\nTo use a limitation you can either provide specific institutes at initiation, or\nafterwards by using \nsetType()\n. Each can take several arguments.\n\n\nYou can provide a single institute:\n\n\nuse Zend\\Validator\\CreditCard;\n\n$valid = new CreditCard(CreditCard::AMERICAN_EXPRESS);\n\n\n\n\nWhen you want to allow multiple institutes, then you can provide them as array:\n\n\nuse Zend\\Validator\\CreditCard;\n\n$valid = new CreditCard([\n    CreditCard::AMERICAN_EXPRESS,\n    CreditCard::VISA\n]);\n\n\n\n\nAnd, as with all validators, you can also pass an associative array of options\nor an instance of \nTraversable\n. In this case you have to provide the institutes\nwith the \ntype\n array key as demostrated here:\n\n\nuse Zend\\Validator\\CreditCard;\n\n$valid = new CreditCard([\n    'type' =\n [CreditCard::AMERICAN_EXPRESS]\n]);\n\n\n\n\nYou can also manipulate institutes after instantiation by using the methods\n\nsetType()\n, \naddType()\n, and \ngetType()\n.\n\n\nuse Zend\\Validator\\CreditCard;\n\n$valid = new CreditCard();\n$valid-\nsetType([\n    CreditCard::AMERICAN_EXPRESS,\n    CreditCard::VISA\n]);\n\n\n\n\n\n\nDefault institute\n\n\nWhen no institute is given at initiation then \nALL\n will be used, which sets\nall institutes at once.\n\n\nIn this case the usage of \naddType()\n is useless because all institutes are\nalready added.\n\n\n\n\nValidation using APIs\n\n\nAs said before \nZend\\Validator\\CreditCard\n will only validate the credit card\nnumber. Fortunately, some institutes provide online APIs which can validate a\ncredit card number by using algorithms which are not available to the public.\nMost of these services are paid services. Therefore, this check is deactivated\nper default.\n\n\nWhen you have access to such an API, then you can use it as an add on for\n\nZend\\Validator\\CreditCard\n and increase the security of the validation.\n\n\nTo do so, provide a callback to invoke when generic validation has passed. This\nprevents the API from being called for invalid numbers, which increases the\nperformance of the application.\n\n\nsetService()\n sets a new service, and \ngetService()\n returns the set service.\nAs a configuration option, you can give the array key \nservice\n at instantiatio.\nFor details about possible options, read the\n\nCallback validator documentation\n.\n\n\nuse Zend\\Validator\\CreditCard;\n\n// Your service class\nclass CcService\n{\n    public function checkOnline($cardnumber, $types)\n    {\n        // some online validation\n    }\n}\n\n// The validation\n$service = new CcService();\n$valid   = new CreditCard(CreditCard::VISA);\n$valid-\nsetService([$service, 'checkOnline']);\n\n\n\n\nThe callback method will be called with the credit card number as the first\nparameter, and the accepted types as the second parameter.", 
            "title": "CreditCard"
        }, 
        {
            "location": "/validators/credit-card/#creditcard-validator", 
            "text": "Zend\\Validator\\CreditCard  allows you to validate if a given value could be a\ncredit card number.  A credit card contains several items of metadata, including a hologram, account\nnumber, logo, expiration date, security code, and the card holder name. The\nalgorithms for verifying the combination of metadata are only known to the\nissuing company, and should be verified with them for purposes of payment.\nHowever, it's often useful to know whether or not a given number actually falls\nwithin the ranges of possible numbers  prior  to performing such verification,\nand, as such,  Zend\\Validator\\CreditCard  verifies that the credit card number\nprovided is well-formed.  For those cases where you have a service that can perform comprehensive\nverification,  Zend\\Validator\\CreditCard  also provides the ability to attach a\nservice callback to trigger once the credit card number has been deemed valid;\nthis callback will then be triggered, and its return value will determine\noverall validity.  The following issuing institutes are accepted:   American Express  China UnionPay  Diners Club Card Blanche  Diners Club International  Diners Club US and Canada  Discover Card  JCB  Laser  Maestro  MasterCard  Solo  Visa  Visa Electron  Russia Mir", 
            "title": "CreditCard Validator"
        }, 
        {
            "location": "/validators/credit-card/#invalid-institutes", 
            "text": "The institutes  Bankcard  and  Diners Club enRoute  no longer exist, and\nare treated as invalid.  Switch  has been rebranded to  Visa  and is therefore also treated as\ninvalid.", 
            "title": "Invalid institutes"
        }, 
        {
            "location": "/validators/credit-card/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\CreditCard :   service : A callback to an online service which will additionally be used for\n  the validation.  type : The type of credit card which will be validated. See the below list of\n  institutes for details.", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/credit-card/#basic-usage", 
            "text": "There are several credit card institutes which can be validated by Zend\\Validator\\CreditCard . Per default, all known institutes will be accepted.\nSee the following example:  $valid = new Zend\\Validator\\CreditCard();\nif ($valid- isValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}  The above example would validate against all known credit card institutes.", 
            "title": "Basic usage"
        }, 
        {
            "location": "/validators/credit-card/#accepting-only-specific-credit-cards", 
            "text": "Sometimes it is necessary to accept only specific credit card institutes instead\nof all; e.g., when you have a webshop which accepts only Visa and American\nExpress cards.  Zend\\Validator\\CreditCard  allows you to do exactly this by\nlimiting it to exactly these institutes.  To use a limitation you can either provide specific institutes at initiation, or\nafterwards by using  setType() . Each can take several arguments.  You can provide a single institute:  use Zend\\Validator\\CreditCard;\n\n$valid = new CreditCard(CreditCard::AMERICAN_EXPRESS);  When you want to allow multiple institutes, then you can provide them as array:  use Zend\\Validator\\CreditCard;\n\n$valid = new CreditCard([\n    CreditCard::AMERICAN_EXPRESS,\n    CreditCard::VISA\n]);  And, as with all validators, you can also pass an associative array of options\nor an instance of  Traversable . In this case you have to provide the institutes\nwith the  type  array key as demostrated here:  use Zend\\Validator\\CreditCard;\n\n$valid = new CreditCard([\n    'type' =  [CreditCard::AMERICAN_EXPRESS]\n]);  You can also manipulate institutes after instantiation by using the methods setType() ,  addType() , and  getType() .  use Zend\\Validator\\CreditCard;\n\n$valid = new CreditCard();\n$valid- setType([\n    CreditCard::AMERICAN_EXPRESS,\n    CreditCard::VISA\n]);", 
            "title": "Accepting only specific credit cards"
        }, 
        {
            "location": "/validators/credit-card/#default-institute", 
            "text": "When no institute is given at initiation then  ALL  will be used, which sets\nall institutes at once.  In this case the usage of  addType()  is useless because all institutes are\nalready added.", 
            "title": "Default institute"
        }, 
        {
            "location": "/validators/credit-card/#validation-using-apis", 
            "text": "As said before  Zend\\Validator\\CreditCard  will only validate the credit card\nnumber. Fortunately, some institutes provide online APIs which can validate a\ncredit card number by using algorithms which are not available to the public.\nMost of these services are paid services. Therefore, this check is deactivated\nper default.  When you have access to such an API, then you can use it as an add on for Zend\\Validator\\CreditCard  and increase the security of the validation.  To do so, provide a callback to invoke when generic validation has passed. This\nprevents the API from being called for invalid numbers, which increases the\nperformance of the application.  setService()  sets a new service, and  getService()  returns the set service.\nAs a configuration option, you can give the array key  service  at instantiatio.\nFor details about possible options, read the Callback validator documentation .  use Zend\\Validator\\CreditCard;\n\n// Your service class\nclass CcService\n{\n    public function checkOnline($cardnumber, $types)\n    {\n        // some online validation\n    }\n}\n\n// The validation\n$service = new CcService();\n$valid   = new CreditCard(CreditCard::VISA);\n$valid- setService([$service, 'checkOnline']);  The callback method will be called with the credit card number as the first\nparameter, and the accepted types as the second parameter.", 
            "title": "Validation using APIs"
        }, 
        {
            "location": "/validators/date/", 
            "text": "Date Validator\n\n\nZend\\Validator\\Date\n allows you to validate if a given value contains a date.\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\Date\n:\n\n\n\n\nformat\n: Sets the format which is used to write the date.\n\n\nlocale\n: Sets the locale which will be used to validate date values.\n\n\n\n\nDefault date validation\n\n\nThe easiest way to validate a date is by using the default date format,\n\nY-m-d\n.\n\n\n$validator = new Zend\\Validator\\Date();\n\n$validator-\nisValid('2000-10-10');   // returns true\n$validator-\nisValid('10.10.2000'); // returns false\n\n\n\n\nSpecifying a date format\n\n\nZend\\Validator\\Date\n also supports custom date formats. When you want to\nvalidate such a date, use the \nformat\n option. This option accepts any format\nallowed by the PHP \nDateTime::createFromFormat()\n method.\n\n\n$validator = new Zend\\Validator\\Date(['format' =\n 'Y']);\n\n$validator-\nisValid('2010'); // returns true\n$validator-\nisValid('May');  // returns false", 
            "title": "Date"
        }, 
        {
            "location": "/validators/date/#date-validator", 
            "text": "Zend\\Validator\\Date  allows you to validate if a given value contains a date.", 
            "title": "Date Validator"
        }, 
        {
            "location": "/validators/date/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\Date :   format : Sets the format which is used to write the date.  locale : Sets the locale which will be used to validate date values.", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/date/#default-date-validation", 
            "text": "The easiest way to validate a date is by using the default date format, Y-m-d .  $validator = new Zend\\Validator\\Date();\n\n$validator- isValid('2000-10-10');   // returns true\n$validator- isValid('10.10.2000'); // returns false", 
            "title": "Default date validation"
        }, 
        {
            "location": "/validators/date/#specifying-a-date-format", 
            "text": "Zend\\Validator\\Date  also supports custom date formats. When you want to\nvalidate such a date, use the  format  option. This option accepts any format\nallowed by the PHP  DateTime::createFromFormat()  method.  $validator = new Zend\\Validator\\Date(['format' =  'Y']);\n\n$validator- isValid('2010'); // returns true\n$validator- isValid('May');  // returns false", 
            "title": "Specifying a date format"
        }, 
        {
            "location": "/validators/db/", 
            "text": "Db\\RecordExists and Db\\NoRecordExists Validators\n\n\nZend\\Validator\\Db\\RecordExists\n and \nZend\\Validator\\Db\\NoRecordExists\n provide\na means to test whether a record exists in a given table of a database, with a\ngiven value.\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\Db\\NoRecordExists\n and\n\nZend\\Validator\\Db\\RecordExists\n:\n\n\n\n\nadapter\n: The database adapter that will be used for the search.\n\n\nexclude\n: Sets records that will be excluded from the search.\n\n\nfield\n: The database field within this table that will be searched for the record.\n\n\nschema\n: Sets the schema that will be used for the search.\n\n\ntable\n: The table that will be searched for the record.\n\n\n\n\nBasic usage\n\n\nAn example of basic usage of the validators:\n\n\n// Check that the email address exists in the database\n$validator = new Zend\\Validator\\Db\\RecordExists([\n    'table'   =\n 'users',\n    'field'   =\n 'emailaddress',\n    'adapter' =\n $dbAdapter,\n]);\n\nif ($validator-\nisValid($emailaddress)) {\n    // email address appears to be valid\n} else {\n    // email address is invalid; print the reasons\n    foreach ($validator-\ngetMessages() as $message) {\n        echo \n$message\\n\n;\n    }\n}\n\n\n\n\nThe above will test that a given email address is in the database table. If no\nrecord is found containing the value of \n$emailaddress\n in the specified column,\nthen an error message is displayed.\n\n\n// Check that the username is not present in the database\n$validator = new Zend\\Validator\\Db\\NoRecordExists([\n    'table'   =\n 'users',\n    'field'   =\n 'username',\n    'adapter' =\n $dbAdapter,\n]);\n\nif ($validator-\nisValid($username)) {\n    // username appears to be valid\n} else {\n    // username is invalid; print the reason\n    $messages = $validator-\ngetMessages();\n    foreach ($messages as $message) {\n        echo \n$message\\n\n;\n    }\n}\n\n\n\n\nThe above will test that a given username is \nnot\n in the database table. If a\nrecord is found containing the value of \n$username\n in the specified column,\nthen an error message is displayed.\n\n\nExcluding records\n\n\nZend\\Validator\\Db\\RecordExists\n and \nZend\\Validator\\Db\\NoRecordExists\n also\nprovide a means to test the database, excluding a part of the table, either by\nproviding a \nWHERE\n clause as a string, or an array with the keys \nfield\n and\n\nvalue\n.\n\n\nWhen providing an array for the exclude clause, the \n!=\n operator is used, so\nyou can check the rest of a table for a value before altering a record (for\nexample on a user profile form)\n\n\n// Check no other users have the username\n$user_id   = $user-\ngetId();\n$validator = new Zend\\Validator\\Db\\NoRecordExists([\n    'table' =\n 'users',\n    'field' =\n 'username',\n    'exclude' =\n [\n        'field' =\n 'id',\n        'value' =\n $user_id,\n    ],\n]);\n\nif ($validator-\nisValid($username)) {\n    // username appears to be valid\n} else {\n    // username is invalid; print the reason\n    $messages = $validator-\ngetMessages();\n    foreach ($messages as $message) {\n        echo \n$message\\n\n;\n    }\n}\n\n\n\n\nThe above example will check the table to ensure no records other than the one\nwhere \nid = $user_id\n contains the value \n$username\n.\n\n\nYou can also provide a string to the exclude clause so you can use an operator\nother than \n!=\n. This can be useful for testing against composite keys.\n\n\n$email     = 'user@example.com';\n$clause    = $dbAdapter-\nquoteIdentifier('email') . ' = ' . $dbAdapter-\nquoteValue($email);\n$validator = new Zend\\Validator\\Db\\RecordExists([\n    'table'   =\n 'users',\n    'field'   =\n 'username',\n    'adapter' =\n $dbAdapter,\n    'exclude' =\n $clause,\n]);\n\nif ($validator-\nisValid($username)) {\n    // username appears to be valid\n} else {\n    // username is invalid; print the reason\n    $messages = $validator-\ngetMessages();\n    foreach ($messages as $message) {\n        echo \n$message\\n\n;\n    }\n}\n\n\n\n\nThe above example will check the \nusers\n table to ensure that only a record with\nboth the username \n$username\n and with the email \n$email\n is valid.\n\n\nDatabase Schemas\n\n\nYou can specify a schema within your database for adapters such as PostgreSQL\nand DB/2 by supplying an array with \ntable\n and \nschema\n keys, as demonstrated\nbelow:\n\n\n$validator = new Zend\\Validator\\Db\\RecordExists([\n    'table'  =\n 'users',\n    'schema' =\n 'my',\n    'field'  =\n 'id',\n]);\n\n\n\n\nUsing a Select object\n\n\nIt is also possible to supply the validators with a \nZend\\Db\\Sql\\Select\n object\nin place of options. The validator then uses this object instead of building its\nown. This allows for greater flexibility with selection of records used for\nvalidation.\n\n\nuse Zend\\Db\\Sql\\Select;\nuse Zend\\Validator\\Db\\RecordExists;\n\n$select = new Select();\n$select\n    -\nfrom('users')\n    -\nwhere-\nequalTo('id', $user_id)\n    -\nwhere-\nequalTo('email', $email);\n\n$validator = new RecordExists($select);\n\n// We still need to set our database adapter\n$validator-\nsetAdapter($dbAdapter);\n\n// Validation is then performed as usual\nif ($validator-\nisValid($username)) {\n    // username appears to be valid\n} else {\n    // username is invalid; print the reason\n    $messages = $validator-\ngetMessages();\n    foreach ($messages as $message) {\n        echo \n$message\\n\n;\n    }\n}\n\n\n\n\nThe above example will check the \nusers\n table to ensure that only a record with\nboth the username \n$username\n and with the email \n$email\n is valid.", 
            "title": "Db\\RecordExists and Db\\NoRecordExists"
        }, 
        {
            "location": "/validators/db/#db92recordexists-and-db92norecordexists-validators", 
            "text": "Zend\\Validator\\Db\\RecordExists  and  Zend\\Validator\\Db\\NoRecordExists  provide\na means to test whether a record exists in a given table of a database, with a\ngiven value.", 
            "title": "Db\\RecordExists and Db\\NoRecordExists Validators"
        }, 
        {
            "location": "/validators/db/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\Db\\NoRecordExists  and Zend\\Validator\\Db\\RecordExists :   adapter : The database adapter that will be used for the search.  exclude : Sets records that will be excluded from the search.  field : The database field within this table that will be searched for the record.  schema : Sets the schema that will be used for the search.  table : The table that will be searched for the record.", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/db/#basic-usage", 
            "text": "An example of basic usage of the validators:  // Check that the email address exists in the database\n$validator = new Zend\\Validator\\Db\\RecordExists([\n    'table'   =  'users',\n    'field'   =  'emailaddress',\n    'adapter' =  $dbAdapter,\n]);\n\nif ($validator- isValid($emailaddress)) {\n    // email address appears to be valid\n} else {\n    // email address is invalid; print the reasons\n    foreach ($validator- getMessages() as $message) {\n        echo  $message\\n ;\n    }\n}  The above will test that a given email address is in the database table. If no\nrecord is found containing the value of  $emailaddress  in the specified column,\nthen an error message is displayed.  // Check that the username is not present in the database\n$validator = new Zend\\Validator\\Db\\NoRecordExists([\n    'table'   =  'users',\n    'field'   =  'username',\n    'adapter' =  $dbAdapter,\n]);\n\nif ($validator- isValid($username)) {\n    // username appears to be valid\n} else {\n    // username is invalid; print the reason\n    $messages = $validator- getMessages();\n    foreach ($messages as $message) {\n        echo  $message\\n ;\n    }\n}  The above will test that a given username is  not  in the database table. If a\nrecord is found containing the value of  $username  in the specified column,\nthen an error message is displayed.", 
            "title": "Basic usage"
        }, 
        {
            "location": "/validators/db/#excluding-records", 
            "text": "Zend\\Validator\\Db\\RecordExists  and  Zend\\Validator\\Db\\NoRecordExists  also\nprovide a means to test the database, excluding a part of the table, either by\nproviding a  WHERE  clause as a string, or an array with the keys  field  and value .  When providing an array for the exclude clause, the  !=  operator is used, so\nyou can check the rest of a table for a value before altering a record (for\nexample on a user profile form)  // Check no other users have the username\n$user_id   = $user- getId();\n$validator = new Zend\\Validator\\Db\\NoRecordExists([\n    'table' =  'users',\n    'field' =  'username',\n    'exclude' =  [\n        'field' =  'id',\n        'value' =  $user_id,\n    ],\n]);\n\nif ($validator- isValid($username)) {\n    // username appears to be valid\n} else {\n    // username is invalid; print the reason\n    $messages = $validator- getMessages();\n    foreach ($messages as $message) {\n        echo  $message\\n ;\n    }\n}  The above example will check the table to ensure no records other than the one\nwhere  id = $user_id  contains the value  $username .  You can also provide a string to the exclude clause so you can use an operator\nother than  != . This can be useful for testing against composite keys.  $email     = 'user@example.com';\n$clause    = $dbAdapter- quoteIdentifier('email') . ' = ' . $dbAdapter- quoteValue($email);\n$validator = new Zend\\Validator\\Db\\RecordExists([\n    'table'   =  'users',\n    'field'   =  'username',\n    'adapter' =  $dbAdapter,\n    'exclude' =  $clause,\n]);\n\nif ($validator- isValid($username)) {\n    // username appears to be valid\n} else {\n    // username is invalid; print the reason\n    $messages = $validator- getMessages();\n    foreach ($messages as $message) {\n        echo  $message\\n ;\n    }\n}  The above example will check the  users  table to ensure that only a record with\nboth the username  $username  and with the email  $email  is valid.", 
            "title": "Excluding records"
        }, 
        {
            "location": "/validators/db/#database-schemas", 
            "text": "You can specify a schema within your database for adapters such as PostgreSQL\nand DB/2 by supplying an array with  table  and  schema  keys, as demonstrated\nbelow:  $validator = new Zend\\Validator\\Db\\RecordExists([\n    'table'  =  'users',\n    'schema' =  'my',\n    'field'  =  'id',\n]);", 
            "title": "Database Schemas"
        }, 
        {
            "location": "/validators/db/#using-a-select-object", 
            "text": "It is also possible to supply the validators with a  Zend\\Db\\Sql\\Select  object\nin place of options. The validator then uses this object instead of building its\nown. This allows for greater flexibility with selection of records used for\nvalidation.  use Zend\\Db\\Sql\\Select;\nuse Zend\\Validator\\Db\\RecordExists;\n\n$select = new Select();\n$select\n    - from('users')\n    - where- equalTo('id', $user_id)\n    - where- equalTo('email', $email);\n\n$validator = new RecordExists($select);\n\n// We still need to set our database adapter\n$validator- setAdapter($dbAdapter);\n\n// Validation is then performed as usual\nif ($validator- isValid($username)) {\n    // username appears to be valid\n} else {\n    // username is invalid; print the reason\n    $messages = $validator- getMessages();\n    foreach ($messages as $message) {\n        echo  $message\\n ;\n    }\n}  The above example will check the  users  table to ensure that only a record with\nboth the username  $username  and with the email  $email  is valid.", 
            "title": "Using a Select object"
        }, 
        {
            "location": "/validators/digits/", 
            "text": "Digits Validator\n\n\nZend\\Validator\\Digits\n validates if a given value contains only digits.\n\n\nSupported options\n\n\nThere are no additional options for \nZend\\Validator\\Digits\n:\n\n\nValidating digits\n\n\nTo validate if a given value contains only digits and no other characters,\ncall the validator as shown below:\n\n\n$validator = new Zend\\Validator\\Digits();\n\n$validator-\nisValid(\n1234567890\n); // returns true\n$validator-\nisValid(1234);         // returns true\n$validator-\nisValid('1a234');      // returns false\n\n\n\n\n\n\nValidating numbers\n\n\nWhen you want to validate numbers or numeric values, be aware that this\nvalidator only validates \ndigits\n. This means that any other sign like a\nthousand separator or a comma will not pass this validator. In this case you\nshould use \nZend\\I18n\\Validator\\IsInt\n or \nZend\\I18n\\Validator\\IsFloat\n.", 
            "title": "Digits"
        }, 
        {
            "location": "/validators/digits/#digits-validator", 
            "text": "Zend\\Validator\\Digits  validates if a given value contains only digits.", 
            "title": "Digits Validator"
        }, 
        {
            "location": "/validators/digits/#supported-options", 
            "text": "There are no additional options for  Zend\\Validator\\Digits :", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/digits/#validating-digits", 
            "text": "To validate if a given value contains only digits and no other characters,\ncall the validator as shown below:  $validator = new Zend\\Validator\\Digits();\n\n$validator- isValid( 1234567890 ); // returns true\n$validator- isValid(1234);         // returns true\n$validator- isValid('1a234');      // returns false", 
            "title": "Validating digits"
        }, 
        {
            "location": "/validators/digits/#validating-numbers", 
            "text": "When you want to validate numbers or numeric values, be aware that this\nvalidator only validates  digits . This means that any other sign like a\nthousand separator or a comma will not pass this validator. In this case you\nshould use  Zend\\I18n\\Validator\\IsInt  or  Zend\\I18n\\Validator\\IsFloat .", 
            "title": "Validating numbers"
        }, 
        {
            "location": "/validators/email-address/", 
            "text": "EmailAddress Validator\n\n\nZend\\Validator\\EmailAddress\n allows you to validate an email address. The\nvalidator first splits the email address on \nlocal-part @ hostname\n and attempts\nto match these against known specifications for email addresses and hostnames.\n\n\nBasic usage\n\n\nA basic example of usage is below:\n\n\n$validator = new Zend\\Validator\\EmailAddress();\n\nif ($validator-\nisValid($email)) {\n    // email appears to be valid\n} else {\n    // email is invalid; print the reasons\n    foreach ($validator-\ngetMessages() as $message) {\n        echo \n$message\\n\n;\n    }\n}\n\n\n\n\nThis will match the email address \n$email\n and on failure populate\n\ngetMessages()\n with useful error messages.\n\n\nSupported Options\n\n\nZend\\Validator\\EmailAddress\n supports several options which can either be set\nat instantiation, by giving an array with the related options, or afterwards, by\nusing \nsetOptions()\n. The following options are supported:\n\n\n\n\nallow\n: Defines which type of domain names are accepted. This option is used\n  in conjunction with the hostnameValidator option to set the hostname validator. \n  Possible values of this option defined in \nHostname\n validator's \n  \nALLOW_*\n constants:\n\n\nALLOW_DNS\n (default) - Allows Internet domain names \n(e.g. example.com)\n\n\nALLOW_IP\n - Allows IP addresses \n(e.g. 192.168.0.1)\n\n\nALLOW_LOCAL\n - Allows local network such as \nlocalhost\n or \nwww.localdomain\n\n\nALLOW_URI\n  - Allows hostnames in URI generic syntax. See \nRFC 3986\n\n\n\n\nALLOW_ALL\n - Allows all types of hostnames\n\n\n\n\n\n\nuseDeepMxCheck\n: Defines if the servers MX records should be verified by a deep check.\n  When this option is set to \ntrue\n then additionally to MX records also the \nA\n,\n  \nA6\n and \nAAAA\n records are used to verify if the server accepts emails. This\n  option defaults to \nfalse\n.\n\n\n\n\nuseDomainCheck\n: Defines if the domain part should be checked. When this option is\n  set to \nfalse\n, then only the local part of the email address will be checked.\n  In this case the hostname validator will not be called. This option defaults\n  to \ntrue\n.\n\n\nhostnameValidator\n: Sets the hostname validator object instance with which the\n  domain part of the email address will be validated.\n\n\nuseMxCheck\n: Defines if the MX records from the server should be detected. If this\n  option is defined to \ntrue\n then the MX records are used to verify if the\n  server accepts emails. This option defaults to \nfalse\n.\n\n\n\n\nComplex local parts\n\n\nZend\\Validator\\EmailAddress\n will match any valid email address according to\nRFC2822. For example, valid emails include \nbob@domain.com\n,\n\nbob+jones@domain.us\n, \n\"bob@jones\"@domain.com*\n and \n\"bob jones\"@domain.com\n\n\nSome obsolete email formats will not currently validate (e.g. carriage returns\nor a \n\\\\\n character in an email address).\n\n\nValidating only the local part\n\n\nIf you need \nZend\\Validator\\EmailAddress\n to check only the local part of an\nemail address, and want to disable validation of the hostname, you can set the\n\ndomain\n option to \nfalse\n. This forces \nZend\\Validator\\EmailAddress\n not to\nvalidate the hostname part of the email address.\n\n\n$validator = new Zend\\Validator\\EmailAddress();\n$validator-\nsetOptions(['domain' =\n FALSE]);\n\n\n\n\nValidating different types of hostnames\n\n\nThe hostname part of an email address is validated against the \nHostname validator\n.\nBy default only DNS hostnames of the form \ndomain.com\n are accepted, though if\nyou wish you can accept IP addresses and Local hostnames too.\n\n\nTo do this you need to instantiate \nZend\\Validator\\EmailAddress\n passing a\nparameter to indicate the type of hostnames you want to accept. More details are\nincluded in \nZend\\Validator\\Hostname\n, though an example of how to accept both\nDNS and Local hostnames appears below:\n\n\nuse Zend\\Validator\\EmailAddress;\nuse Zend\\Validator\\Hostname;\n\n$validator = new EmailAddress( Hostname::ALLOW_DNS | Hostname::ALLOW_LOCAL);\n\nif ($validator-\nisValid($email)) {\n    // email appears to be valid\n} else {\n    // email is invalid; print the reasons\n    foreach ($validator-\ngetMessages() as $message) {\n        echo \n$message\\n\n;\n    }\n}\n\n\n\n\nChecking if the hostname actually accepts email\n\n\nJust because an email address is in the correct format, it doesn't necessarily\nmean that email address actually exists. To help solve this problem, you can use\nMX validation to check whether an MX (email) entry exists in the DNS record for\nthe email's hostname. This tells you that the hostname accepts email, but\ndoesn't tell you the exact email address itself is valid.\n\n\nMX checking is not enabled by default. To enable MX checking you can pass a\nsecond parameter to the \nZend\\Validator\\EmailAddress\n constructor.\n\n\n$validator = new Zend\\Validator\\EmailAddress([\n    'allow' =\n Zend\\Validator\\Hostname::ALLOW_DNS,\n    'useMxCheck'    =\n true,\n]);\n\n\n\n\nAlternatively you can either pass \ntrue\n or \nfalse\n to \nsetValidateMx()\n to\nenable or disable MX validation.\n\n\nBy enabling this setting, network functions will be used to check for the\npresence of an MX record on the hostname of the email address you wish to\nvalidate. Please be aware this will likely slow your script down.\n\n\nSometimes validation for MX records returns \nfalse\n, even if emails are\naccepted. The reason behind this behaviour is, that servers can accept emails\neven if they do not provide a MX record. In this case they can provide \nA\n,\n\nA6\n, or \nAAAA\n records. To allow \nZend\\Validator\\EmailAddress\n to check also\nfor these other records, you need to set deep MX validation. This can be done at\ninitiation by setting the \ndeep\n option or by using \nsetOptions()\n.\n\n\n$validator = new Zend\\Validator\\EmailAddress([\n    'allow' =\n Zend\\Validator\\Hostname::ALLOW_DNS,\n    'useMxCheck'    =\n true,\n    'useDeepMxCheck'  =\n true,\n]);\n\n\n\n\nSometimes it can be useful to get the server's MX information which have been\nused to do further processing. Simply use \ngetMXRecord()\n after validation. This\nmethod returns the received MX record including weight and sorted by it.\n\n\n\n\nPerformance warning**\n\n\nYou should be aware that enabling MX check will slow down you script because\nof the used network functions. Enabling deep check will slow down your script\neven more as it searches the given server for 3 additional types.\n\n\nDisallowed IP addresses\n\n\nYou should note that MX validation is only accepted for external servers. When\ndeep MX validation is enabled, then local IP addresses like \n192.168.*\n or\n\n169.254.*\n are not accepted.\n\n\n\n\nValidating International Domains Names\n\n\nZend\\Validator\\EmailAddress\n will also match international characters that\nexist in some domains. This is known as International Domain Name (IDN) support.\nThis is enabled by default, though you can disable this by changing the setting\nvia the internal \nZend\\Validator\\Hostname\n object that exists within\n\nZend\\Validator\\EmailAddress\n.\n\n\n$validator-\ngetHostnameValidator()-\nsetValidateIdn(false);\n\n\n\n\nMore information on the usage of \nsetValidateIdn()\n appears in the\n\nHostname documentation\n.\n\n\nPlease note IDNs are only validated if you allow DNS hostnames to be validated.\n\n\nValidating Top Level Domains\n\n\nBy default a hostname will be checked against a list of known TLDs. This is\nenabled by default, though you can disable this by changing the setting via the\ninternal \nZend\\Validator\\Hostname\n object that exists within\n\nZend\\Validator\\EmailAddress\n.\n\n\n$validator-\ngetHostnameValidator()-\nsetValidateTld(false);\n\n\n\n\nMore information on the usage of \nsetValidateTld()\n appears in the\n\nHostname documentation\n.\n\n\nPlease note TLDs are only validated if you allow DNS hostnames to be validated.\n\n\nSetting messages\n\n\nZend\\Validator\\EmailAddress\n makes also use of \nZend\\Validator\\Hostname\n to\ncheck the hostname part of a given email address. You can specify messages for\n\nZend\\Validator\\Hostname\n from within \nZend\\Validator\\EmailAddress\n.\n\n\n$validator = new Zend\\Validator\\EmailAddress();\n$validator-\nsetMessages([\n    Zend\\Validator\\Hostname::UNKNOWN_TLD =\n 'I don\\'t know the TLD you gave'\n]);", 
            "title": "EmailAddress"
        }, 
        {
            "location": "/validators/email-address/#emailaddress-validator", 
            "text": "Zend\\Validator\\EmailAddress  allows you to validate an email address. The\nvalidator first splits the email address on  local-part @ hostname  and attempts\nto match these against known specifications for email addresses and hostnames.", 
            "title": "EmailAddress Validator"
        }, 
        {
            "location": "/validators/email-address/#basic-usage", 
            "text": "A basic example of usage is below:  $validator = new Zend\\Validator\\EmailAddress();\n\nif ($validator- isValid($email)) {\n    // email appears to be valid\n} else {\n    // email is invalid; print the reasons\n    foreach ($validator- getMessages() as $message) {\n        echo  $message\\n ;\n    }\n}  This will match the email address  $email  and on failure populate getMessages()  with useful error messages.", 
            "title": "Basic usage"
        }, 
        {
            "location": "/validators/email-address/#supported-options", 
            "text": "Zend\\Validator\\EmailAddress  supports several options which can either be set\nat instantiation, by giving an array with the related options, or afterwards, by\nusing  setOptions() . The following options are supported:   allow : Defines which type of domain names are accepted. This option is used\n  in conjunction with the hostnameValidator option to set the hostname validator. \n  Possible values of this option defined in  Hostname  validator's \n   ALLOW_*  constants:  ALLOW_DNS  (default) - Allows Internet domain names  (e.g. example.com)  ALLOW_IP  - Allows IP addresses  (e.g. 192.168.0.1)  ALLOW_LOCAL  - Allows local network such as  localhost  or  www.localdomain  ALLOW_URI   - Allows hostnames in URI generic syntax. See  RFC 3986   ALLOW_ALL  - Allows all types of hostnames    useDeepMxCheck : Defines if the servers MX records should be verified by a deep check.\n  When this option is set to  true  then additionally to MX records also the  A ,\n   A6  and  AAAA  records are used to verify if the server accepts emails. This\n  option defaults to  false .   useDomainCheck : Defines if the domain part should be checked. When this option is\n  set to  false , then only the local part of the email address will be checked.\n  In this case the hostname validator will not be called. This option defaults\n  to  true .  hostnameValidator : Sets the hostname validator object instance with which the\n  domain part of the email address will be validated.  useMxCheck : Defines if the MX records from the server should be detected. If this\n  option is defined to  true  then the MX records are used to verify if the\n  server accepts emails. This option defaults to  false .", 
            "title": "Supported Options"
        }, 
        {
            "location": "/validators/email-address/#complex-local-parts", 
            "text": "Zend\\Validator\\EmailAddress  will match any valid email address according to\nRFC2822. For example, valid emails include  bob@domain.com , bob+jones@domain.us ,  \"bob@jones\"@domain.com*  and  \"bob jones\"@domain.com  Some obsolete email formats will not currently validate (e.g. carriage returns\nor a  \\\\  character in an email address).", 
            "title": "Complex local parts"
        }, 
        {
            "location": "/validators/email-address/#validating-only-the-local-part", 
            "text": "If you need  Zend\\Validator\\EmailAddress  to check only the local part of an\nemail address, and want to disable validation of the hostname, you can set the domain  option to  false . This forces  Zend\\Validator\\EmailAddress  not to\nvalidate the hostname part of the email address.  $validator = new Zend\\Validator\\EmailAddress();\n$validator- setOptions(['domain' =  FALSE]);", 
            "title": "Validating only the local part"
        }, 
        {
            "location": "/validators/email-address/#validating-different-types-of-hostnames", 
            "text": "The hostname part of an email address is validated against the  Hostname validator .\nBy default only DNS hostnames of the form  domain.com  are accepted, though if\nyou wish you can accept IP addresses and Local hostnames too.  To do this you need to instantiate  Zend\\Validator\\EmailAddress  passing a\nparameter to indicate the type of hostnames you want to accept. More details are\nincluded in  Zend\\Validator\\Hostname , though an example of how to accept both\nDNS and Local hostnames appears below:  use Zend\\Validator\\EmailAddress;\nuse Zend\\Validator\\Hostname;\n\n$validator = new EmailAddress( Hostname::ALLOW_DNS | Hostname::ALLOW_LOCAL);\n\nif ($validator- isValid($email)) {\n    // email appears to be valid\n} else {\n    // email is invalid; print the reasons\n    foreach ($validator- getMessages() as $message) {\n        echo  $message\\n ;\n    }\n}", 
            "title": "Validating different types of hostnames"
        }, 
        {
            "location": "/validators/email-address/#checking-if-the-hostname-actually-accepts-email", 
            "text": "Just because an email address is in the correct format, it doesn't necessarily\nmean that email address actually exists. To help solve this problem, you can use\nMX validation to check whether an MX (email) entry exists in the DNS record for\nthe email's hostname. This tells you that the hostname accepts email, but\ndoesn't tell you the exact email address itself is valid.  MX checking is not enabled by default. To enable MX checking you can pass a\nsecond parameter to the  Zend\\Validator\\EmailAddress  constructor.  $validator = new Zend\\Validator\\EmailAddress([\n    'allow' =  Zend\\Validator\\Hostname::ALLOW_DNS,\n    'useMxCheck'    =  true,\n]);  Alternatively you can either pass  true  or  false  to  setValidateMx()  to\nenable or disable MX validation.  By enabling this setting, network functions will be used to check for the\npresence of an MX record on the hostname of the email address you wish to\nvalidate. Please be aware this will likely slow your script down.  Sometimes validation for MX records returns  false , even if emails are\naccepted. The reason behind this behaviour is, that servers can accept emails\neven if they do not provide a MX record. In this case they can provide  A , A6 , or  AAAA  records. To allow  Zend\\Validator\\EmailAddress  to check also\nfor these other records, you need to set deep MX validation. This can be done at\ninitiation by setting the  deep  option or by using  setOptions() .  $validator = new Zend\\Validator\\EmailAddress([\n    'allow' =  Zend\\Validator\\Hostname::ALLOW_DNS,\n    'useMxCheck'    =  true,\n    'useDeepMxCheck'  =  true,\n]);  Sometimes it can be useful to get the server's MX information which have been\nused to do further processing. Simply use  getMXRecord()  after validation. This\nmethod returns the received MX record including weight and sorted by it.", 
            "title": "Checking if the hostname actually accepts email"
        }, 
        {
            "location": "/validators/email-address/#performance-warning", 
            "text": "You should be aware that enabling MX check will slow down you script because\nof the used network functions. Enabling deep check will slow down your script\neven more as it searches the given server for 3 additional types.", 
            "title": "Performance warning**"
        }, 
        {
            "location": "/validators/email-address/#disallowed-ip-addresses", 
            "text": "You should note that MX validation is only accepted for external servers. When\ndeep MX validation is enabled, then local IP addresses like  192.168.*  or 169.254.*  are not accepted.", 
            "title": "Disallowed IP addresses"
        }, 
        {
            "location": "/validators/email-address/#validating-international-domains-names", 
            "text": "Zend\\Validator\\EmailAddress  will also match international characters that\nexist in some domains. This is known as International Domain Name (IDN) support.\nThis is enabled by default, though you can disable this by changing the setting\nvia the internal  Zend\\Validator\\Hostname  object that exists within Zend\\Validator\\EmailAddress .  $validator- getHostnameValidator()- setValidateIdn(false);  More information on the usage of  setValidateIdn()  appears in the Hostname documentation .  Please note IDNs are only validated if you allow DNS hostnames to be validated.", 
            "title": "Validating International Domains Names"
        }, 
        {
            "location": "/validators/email-address/#validating-top-level-domains", 
            "text": "By default a hostname will be checked against a list of known TLDs. This is\nenabled by default, though you can disable this by changing the setting via the\ninternal  Zend\\Validator\\Hostname  object that exists within Zend\\Validator\\EmailAddress .  $validator- getHostnameValidator()- setValidateTld(false);  More information on the usage of  setValidateTld()  appears in the Hostname documentation .  Please note TLDs are only validated if you allow DNS hostnames to be validated.", 
            "title": "Validating Top Level Domains"
        }, 
        {
            "location": "/validators/email-address/#setting-messages", 
            "text": "Zend\\Validator\\EmailAddress  makes also use of  Zend\\Validator\\Hostname  to\ncheck the hostname part of a given email address. You can specify messages for Zend\\Validator\\Hostname  from within  Zend\\Validator\\EmailAddress .  $validator = new Zend\\Validator\\EmailAddress();\n$validator- setMessages([\n    Zend\\Validator\\Hostname::UNKNOWN_TLD =  'I don\\'t know the TLD you gave'\n]);", 
            "title": "Setting messages"
        }, 
        {
            "location": "/validators/explode/", 
            "text": "Explode Validator\n\n\nZend\\Validator\\Explode\n executes a validator for each item exploded from an\narray.\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\Explode\n:\n\n\n\n\nvalueDelimiter\n: Defines the delimiter used to explode values from an array.\n  It defaults to \n,\n. If the given value is an array, this option isn't used.\n\n\nvalidator\n: Sets the validator that will be executed on each exploded item.\n  This may be a validator instance, or a validator service name.\n\n\n\n\nBasic usage\n\n\nTo validate if every item in an array is in a specified haystack:\n\n\n$inArrayValidator = new Zend\\Validator\\InArray([\n    'haystack' =\n [1, 2, 3, 4, 5, 6],\n]);\n\n$explodeValidator = new Zend\\Validator\\Explode([\n    'validator' =\n $inArrayValidator\n]);\n\n$explodeValidator-\nisValid([1, 4, 6]);    // returns true\n$explodeValidator-\nisValid([1, 4, 6, 8]); // returns false\n\n\n\n\nExploding strings\n\n\nTo validate if every e-mail in a string is contained in a list of names:\n\n\n$inEmailListValidator = new Zend\\Validator\\InArray([\n    'haystack' =\n ['joseph@test.com', 'mark@test.com', 'lucia@test.com'],\n]);\n\n$explodeValidator = new Zend\\Validator\\Explode([\n    'validator' =\n $inEmailListValidator,\n    'valueDelimiter' =\n ','\n]);\n\n$explodeValidator-\nisValid('joseph@test.com,mark@test.com'); // returns true\n$explodeValidator-\nisValid('lucia@test.com,maria@test.com');  // returns false", 
            "title": "Explode"
        }, 
        {
            "location": "/validators/explode/#explode-validator", 
            "text": "Zend\\Validator\\Explode  executes a validator for each item exploded from an\narray.", 
            "title": "Explode Validator"
        }, 
        {
            "location": "/validators/explode/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\Explode :   valueDelimiter : Defines the delimiter used to explode values from an array.\n  It defaults to  , . If the given value is an array, this option isn't used.  validator : Sets the validator that will be executed on each exploded item.\n  This may be a validator instance, or a validator service name.", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/explode/#basic-usage", 
            "text": "To validate if every item in an array is in a specified haystack:  $inArrayValidator = new Zend\\Validator\\InArray([\n    'haystack' =  [1, 2, 3, 4, 5, 6],\n]);\n\n$explodeValidator = new Zend\\Validator\\Explode([\n    'validator' =  $inArrayValidator\n]);\n\n$explodeValidator- isValid([1, 4, 6]);    // returns true\n$explodeValidator- isValid([1, 4, 6, 8]); // returns false", 
            "title": "Basic usage"
        }, 
        {
            "location": "/validators/explode/#exploding-strings", 
            "text": "To validate if every e-mail in a string is contained in a list of names:  $inEmailListValidator = new Zend\\Validator\\InArray([\n    'haystack' =  ['joseph@test.com', 'mark@test.com', 'lucia@test.com'],\n]);\n\n$explodeValidator = new Zend\\Validator\\Explode([\n    'validator' =  $inEmailListValidator,\n    'valueDelimiter' =  ','\n]);\n\n$explodeValidator- isValid('joseph@test.com,mark@test.com'); // returns true\n$explodeValidator- isValid('lucia@test.com,maria@test.com');  // returns false", 
            "title": "Exploding strings"
        }, 
        {
            "location": "/validators/greater-than/", 
            "text": "GreaterThan Validator\n\n\nZend\\Validator\\GreaterThan\n allows you to validate if a given value is greater\nthan a minimum border value.\n\n\n\n\nOnly supports numbers\n\n\nZend\\Validator\\GreaterThan\n supports only the validation of numbers. Strings\nor dates can not be validated with this validator.\n\n\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\GreaterThan\n:\n\n\n\n\ninclusive\n: Defines if the validation is inclusive of the minimum value,\n  or exclusive. It defaults to \nfalse\n.\n\n\nmin\n: Sets the minimum allowed value.\n\n\n\n\nBasic usage\n\n\nTo validate if a given value is greater than a defined minimum:\n\n\n$valid  = new Zend\\Validator\\GreaterThan(['min' =\n 10]);\n$value  = 8;\n$return = $valid-\nisValid($value);\n// returns false\n\n\n\n\nThe above example returns \ntrue\n for all values which are greater than 10.\n\n\nInclusive validation\n\n\nSometimes it is useful to validate a value by including the minimum value.\n\n\n$valid  = new Zend\\Validator\\GreaterThan([\n    'min' =\n 10,\n    'inclusive' =\n true,\n]);\n$value  = 10;\n$result = $valid-\nisValid($value);\n// returns true\n\n\n\n\nThe example is identical to our first example, with the exception that we\nincluded the minimum value. Now the value '10' is allowed and will return\n\ntrue\n.", 
            "title": "GreaterThan"
        }, 
        {
            "location": "/validators/greater-than/#greaterthan-validator", 
            "text": "Zend\\Validator\\GreaterThan  allows you to validate if a given value is greater\nthan a minimum border value.", 
            "title": "GreaterThan Validator"
        }, 
        {
            "location": "/validators/greater-than/#only-supports-numbers", 
            "text": "Zend\\Validator\\GreaterThan  supports only the validation of numbers. Strings\nor dates can not be validated with this validator.", 
            "title": "Only supports numbers"
        }, 
        {
            "location": "/validators/greater-than/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\GreaterThan :   inclusive : Defines if the validation is inclusive of the minimum value,\n  or exclusive. It defaults to  false .  min : Sets the minimum allowed value.", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/greater-than/#basic-usage", 
            "text": "To validate if a given value is greater than a defined minimum:  $valid  = new Zend\\Validator\\GreaterThan(['min' =  10]);\n$value  = 8;\n$return = $valid- isValid($value);\n// returns false  The above example returns  true  for all values which are greater than 10.", 
            "title": "Basic usage"
        }, 
        {
            "location": "/validators/greater-than/#inclusive-validation", 
            "text": "Sometimes it is useful to validate a value by including the minimum value.  $valid  = new Zend\\Validator\\GreaterThan([\n    'min' =  10,\n    'inclusive' =  true,\n]);\n$value  = 10;\n$result = $valid- isValid($value);\n// returns true  The example is identical to our first example, with the exception that we\nincluded the minimum value. Now the value '10' is allowed and will return true .", 
            "title": "Inclusive validation"
        }, 
        {
            "location": "/validators/hex/", 
            "text": "Hex Validator\n\n\nZend\\Validator\\Hex\n allows you to validate if a given value contains only\nhexadecimal characters. These are all characters from \n0 to 9\n and \nA to F\n,\ncase insensitive. There is no length limitation for the input you want to\nvalidate.\n\n\n$validator = new Zend\\Validator\\Hex();\nif ($validator-\nisValid('123ABC')) {\n    // value contains only hex chars\n} else {\n    // false\n}\n\n\n\n\n\n\nInvalid characters\n\n\nAll other characters will return false, including whitespace and decimal\npoints. Additionally, unicode zeros and numbers from other scripts than latin\nwill not be treated as valid.\n\n\n\n\nSupported options\n\n\nThere are no additional options for \nZend\\Validator\\Hex\n.", 
            "title": "Hex"
        }, 
        {
            "location": "/validators/hex/#hex-validator", 
            "text": "Zend\\Validator\\Hex  allows you to validate if a given value contains only\nhexadecimal characters. These are all characters from  0 to 9  and  A to F ,\ncase insensitive. There is no length limitation for the input you want to\nvalidate.  $validator = new Zend\\Validator\\Hex();\nif ($validator- isValid('123ABC')) {\n    // value contains only hex chars\n} else {\n    // false\n}", 
            "title": "Hex Validator"
        }, 
        {
            "location": "/validators/hex/#invalid-characters", 
            "text": "All other characters will return false, including whitespace and decimal\npoints. Additionally, unicode zeros and numbers from other scripts than latin\nwill not be treated as valid.", 
            "title": "Invalid characters"
        }, 
        {
            "location": "/validators/hex/#supported-options", 
            "text": "There are no additional options for  Zend\\Validator\\Hex .", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/hostname/", 
            "text": "Hostname Validator\n\n\nZend\\Validator\\Hostname\n allows you to validate a hostname against a set of\nknown specifications. It is possible to check for three different types of\nhostnames: a DNS Hostname (i.e. \ndomain.com\n), IP address (i.e. 1.2.3.4), and\nLocal hostnames (i.e. localhost). By default, only DNS hostnames are matched.\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\Hostname\n:\n\n\n\n\nallow\n: Defines the sort of hostname which is allowed to be used.\n  \nSee below\n for details.\n\n\nidn\n: Defines if IDN domains are allowed or not. This option defaults to\n  \ntrue\n.\n\n\nip\n: Allows defining a custom IP validator. This option defaults to a new\n  instance of \nZend\\Validator\\Ip\n.\n\n\ntld\n: Defines if TLDs are validated. This option defaults to \ntrue\n.\n\n\n\n\nBasic usage\n\n\n$validator = new Zend\\Validator\\Hostname();\n\nif ($validator-\nisValid($hostname)) {\n    // hostname appears to be valid\n} else {\n    // hostname is invalid; print the reasons\n    foreach ($validator-\ngetMessages() as $message) {\n        echo \n$message\\n\n;\n    }\n}\n\n\n\n\nThis will match the hostname \n$hostname\n and on failure populate \ngetMessages()\n\nwith useful error messages.\n\n\nValidating different types of hostnames\n\n\nYou may find you also want to match IP addresses, Local hostnames, or a\ncombination of all allowed types. This can be done by passing a parameter to\n\nZend\\Validator\\Hostname\n when you instantiate it. The parameter should be an\ninteger which determines what types of hostnames are allowed. You are encouraged\nto use the \nZend\\Validator\\Hostname\n constants to do this.\n\n\nThe \nZend\\Validator\\Hostname\n constants are:\n\n\n\n\nALLOW_DNS\n, to allow only DNS hostnames\n\n\nALLOW_IP\n to allow IP addresses\n\n\nALLOW_LOCAL\n to allow local network names\n\n\nALLOW_URI\n to allow \nRFC3986\n-compliant addresses\n\n\nALLOW_ALL\n to allow all four above types\n\n\n\n\n\n\nAdditional Information on \nALLOW_URI\n\n\nALLOW_URI\n allows checking hostnames according to\n\nRFC3986\n. These are registered names\nwhich are used by WINS, NetInfo and also local hostnames like those defined\nwithin your \nhosts\n file.\n\n\n\n\nTo check for IP addresses only, you can use the example below:\n\n\nuse Zend\\Validator\\Hostname;\n\n$validator = new Hostname(Hostname::ALLOW_IP);\n\nif ($validator-\nisValid($hostname)) {\n    // hostname appears to be valid\n} else {\n    // hostname is invalid; print the reasons\n    foreach ($validator-\ngetMessages() as $message) {\n        echo \n$message\\n\n;\n    }\n}\n\n\n\n\nAs well as using \nALLOW_ALL\n to accept all common hostnames types, you can\ncombine these types to allow for combinations. For example, to accept DNS and\nLocal hostnames:\n\n\nuse Zend\\Validator\\Hostname;\n\n$validator = new Hostname(Hostname::ALLOW_DNS | Hostname::ALLOW_IP);\n\n\n\n\nValidating International Domains Names\n\n\nSome Country Code Top Level Domains (ccTLDs), such as 'de' (Germany), support\ninternational characters in domain names. These are known as International\nDomain Names (IDN). These domains can be matched by \nZend\\Validator\\Hostname\n\nvia extended characters that are used in the validation process.\n\n\nAt the time of writing, more than 50 ccTLDs support IDN domains.\n\n\nThe \nHostname\n validator matches IDN domains by default.  If you wish to disable\nIDN validation, either pass a parameter to the \nZend\\Validator\\Hostname\n\nconstructor or call the \nsetValidateIdn()\n method.\n\n\nYou can disable IDN validation by passing a second parameter to the\n\nZend\\Validator\\Hostname\n constructor in the following way.\n\n\n$validator = new Zend\\Validator\\Hostname([\n    'allow' =\n Zend\\Validator\\Hostname::ALLOW_DNS,\n    'useIdnCheck'   =\n false,\n]);\n\n\n\n\nAlternatively you can either pass \ntrue\n or \nfalse\n to \nsetValidateIdn()\n to\nenable or disable IDN validation. If you are trying to match an IDN hostname\nwhich isn't currently supported, it is likely it will fail validation if it has\nany international characters in it. Where a ccTLD file doesn't exist in\n\nZend/Validator/Hostname\n specifying the additional characters, a normal hostname\nvalidation is performed.\n\n\nPlease note that IDNs are only validated if you allow DNS hostnames to be\nvalidated.\n\n\nValidating Top Level Domains\n\n\nBy default, a hostname will be verified against a list of known TLDs. If this\nfunctionality is not required, it can be disabled in much the same way as\ndisabling IDN support. You can disable TLD validation by passing a third\nparameter to the \nZend\\Validator\\Hostname\n constructor. In the example below we\nare supporting IDN validation via the second parameter.\n\n\nuse Zend\\Validator\\Hostname;\n\n$validator = new Hostname([\n    'allow' =\n Hostname::ALLOW_DNS,\n    'useIdnCheck'   =\n true,\n    'useTldCheck'   =\n false,\n]);\n\n\n\n\nAlternatively you can either pass \ntrue\n or \nfalse\n to \nsetValidateTld()\n to\nenable or disable TLD validation.\n\n\nPlease note, TLDs are only validated if you allow DNS hostnames to be validated.", 
            "title": "Hostname"
        }, 
        {
            "location": "/validators/hostname/#hostname-validator", 
            "text": "Zend\\Validator\\Hostname  allows you to validate a hostname against a set of\nknown specifications. It is possible to check for three different types of\nhostnames: a DNS Hostname (i.e.  domain.com ), IP address (i.e. 1.2.3.4), and\nLocal hostnames (i.e. localhost). By default, only DNS hostnames are matched.", 
            "title": "Hostname Validator"
        }, 
        {
            "location": "/validators/hostname/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\Hostname :   allow : Defines the sort of hostname which is allowed to be used.\n   See below  for details.  idn : Defines if IDN domains are allowed or not. This option defaults to\n   true .  ip : Allows defining a custom IP validator. This option defaults to a new\n  instance of  Zend\\Validator\\Ip .  tld : Defines if TLDs are validated. This option defaults to  true .", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/hostname/#basic-usage", 
            "text": "$validator = new Zend\\Validator\\Hostname();\n\nif ($validator- isValid($hostname)) {\n    // hostname appears to be valid\n} else {\n    // hostname is invalid; print the reasons\n    foreach ($validator- getMessages() as $message) {\n        echo  $message\\n ;\n    }\n}  This will match the hostname  $hostname  and on failure populate  getMessages() \nwith useful error messages.", 
            "title": "Basic usage"
        }, 
        {
            "location": "/validators/hostname/#validating-different-types-of-hostnames", 
            "text": "You may find you also want to match IP addresses, Local hostnames, or a\ncombination of all allowed types. This can be done by passing a parameter to Zend\\Validator\\Hostname  when you instantiate it. The parameter should be an\ninteger which determines what types of hostnames are allowed. You are encouraged\nto use the  Zend\\Validator\\Hostname  constants to do this.  The  Zend\\Validator\\Hostname  constants are:   ALLOW_DNS , to allow only DNS hostnames  ALLOW_IP  to allow IP addresses  ALLOW_LOCAL  to allow local network names  ALLOW_URI  to allow  RFC3986 -compliant addresses  ALLOW_ALL  to allow all four above types", 
            "title": "Validating different types of hostnames"
        }, 
        {
            "location": "/validators/hostname/#additional-information-on-allow_uri", 
            "text": "ALLOW_URI  allows checking hostnames according to RFC3986 . These are registered names\nwhich are used by WINS, NetInfo and also local hostnames like those defined\nwithin your  hosts  file.   To check for IP addresses only, you can use the example below:  use Zend\\Validator\\Hostname;\n\n$validator = new Hostname(Hostname::ALLOW_IP);\n\nif ($validator- isValid($hostname)) {\n    // hostname appears to be valid\n} else {\n    // hostname is invalid; print the reasons\n    foreach ($validator- getMessages() as $message) {\n        echo  $message\\n ;\n    }\n}  As well as using  ALLOW_ALL  to accept all common hostnames types, you can\ncombine these types to allow for combinations. For example, to accept DNS and\nLocal hostnames:  use Zend\\Validator\\Hostname;\n\n$validator = new Hostname(Hostname::ALLOW_DNS | Hostname::ALLOW_IP);", 
            "title": "Additional Information on ALLOW_URI"
        }, 
        {
            "location": "/validators/hostname/#validating-international-domains-names", 
            "text": "Some Country Code Top Level Domains (ccTLDs), such as 'de' (Germany), support\ninternational characters in domain names. These are known as International\nDomain Names (IDN). These domains can be matched by  Zend\\Validator\\Hostname \nvia extended characters that are used in the validation process.  At the time of writing, more than 50 ccTLDs support IDN domains.  The  Hostname  validator matches IDN domains by default.  If you wish to disable\nIDN validation, either pass a parameter to the  Zend\\Validator\\Hostname \nconstructor or call the  setValidateIdn()  method.  You can disable IDN validation by passing a second parameter to the Zend\\Validator\\Hostname  constructor in the following way.  $validator = new Zend\\Validator\\Hostname([\n    'allow' =  Zend\\Validator\\Hostname::ALLOW_DNS,\n    'useIdnCheck'   =  false,\n]);  Alternatively you can either pass  true  or  false  to  setValidateIdn()  to\nenable or disable IDN validation. If you are trying to match an IDN hostname\nwhich isn't currently supported, it is likely it will fail validation if it has\nany international characters in it. Where a ccTLD file doesn't exist in Zend/Validator/Hostname  specifying the additional characters, a normal hostname\nvalidation is performed.  Please note that IDNs are only validated if you allow DNS hostnames to be\nvalidated.", 
            "title": "Validating International Domains Names"
        }, 
        {
            "location": "/validators/hostname/#validating-top-level-domains", 
            "text": "By default, a hostname will be verified against a list of known TLDs. If this\nfunctionality is not required, it can be disabled in much the same way as\ndisabling IDN support. You can disable TLD validation by passing a third\nparameter to the  Zend\\Validator\\Hostname  constructor. In the example below we\nare supporting IDN validation via the second parameter.  use Zend\\Validator\\Hostname;\n\n$validator = new Hostname([\n    'allow' =  Hostname::ALLOW_DNS,\n    'useIdnCheck'   =  true,\n    'useTldCheck'   =  false,\n]);  Alternatively you can either pass  true  or  false  to  setValidateTld()  to\nenable or disable TLD validation.  Please note, TLDs are only validated if you allow DNS hostnames to be validated.", 
            "title": "Validating Top Level Domains"
        }, 
        {
            "location": "/validators/iban/", 
            "text": "Iban Validator\n\n\nZend\\Validator\\Iban\n validates if a given value could be a IBAN number. IBAN is\nthe abbreviation for \"International Bank Account Number\".\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\Iban\n:\n\n\n\n\ncountry_code\n: Sets the country code which is used to get the IBAN format\n  for validation.\n\n\n\n\nIBAN validation\n\n\nIBAN numbers are always related to a country. This means that different\ncountries use different formats for their IBAN numbers. This is the reason why\nIBAN numbers always need a country code. By knowing this we already know how\nto use \nZend\\Validator\\Iban\n.\n\n\nUngreedy IBAN validation\n\n\nSometime it is useful just to validate if the given value is a IBAN number or\nnot. This means that you don't want to validate it against a defined country.\nThis can be done by using \nfalse\n as locale.\n\n\n$validator = new Zend\\Validator\\Iban(['country_code' =\n false]);\n// Note: you can also provide FALSE as the sole parameter\n\nif ($validator-\nisValid('AT611904300234573201')) {\n    // IBAN appears to be valid\n} else {\n    // IBAN is not valid\n}\n\n\n\n\nIn this situation, any IBAN number from any country will considered valid. Note\nthat this should not be done when you accept only accounts from a single\ncountry!\n\n\nRegion aware IBAN validation\n\n\nTo validate against a defined country, you just provide a country code. You can\ndo this during instaniation via the option \ncountry_code\n, or afterwards by\nusing \nsetCountryCode()\n.\n\n\n$validator = new Zend\\Validator\\Iban(['country_code' =\n 'AT']);\n\nif ($validator-\nisValid('AT611904300234573201')) {\n    // IBAN appears to be valid\n} else {\n    // IBAN is not valid\n}", 
            "title": "Iban"
        }, 
        {
            "location": "/validators/iban/#iban-validator", 
            "text": "Zend\\Validator\\Iban  validates if a given value could be a IBAN number. IBAN is\nthe abbreviation for \"International Bank Account Number\".", 
            "title": "Iban Validator"
        }, 
        {
            "location": "/validators/iban/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\Iban :   country_code : Sets the country code which is used to get the IBAN format\n  for validation.", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/iban/#iban-validation", 
            "text": "IBAN numbers are always related to a country. This means that different\ncountries use different formats for their IBAN numbers. This is the reason why\nIBAN numbers always need a country code. By knowing this we already know how\nto use  Zend\\Validator\\Iban .", 
            "title": "IBAN validation"
        }, 
        {
            "location": "/validators/iban/#ungreedy-iban-validation", 
            "text": "Sometime it is useful just to validate if the given value is a IBAN number or\nnot. This means that you don't want to validate it against a defined country.\nThis can be done by using  false  as locale.  $validator = new Zend\\Validator\\Iban(['country_code' =  false]);\n// Note: you can also provide FALSE as the sole parameter\n\nif ($validator- isValid('AT611904300234573201')) {\n    // IBAN appears to be valid\n} else {\n    // IBAN is not valid\n}  In this situation, any IBAN number from any country will considered valid. Note\nthat this should not be done when you accept only accounts from a single\ncountry!", 
            "title": "Ungreedy IBAN validation"
        }, 
        {
            "location": "/validators/iban/#region-aware-iban-validation", 
            "text": "To validate against a defined country, you just provide a country code. You can\ndo this during instaniation via the option  country_code , or afterwards by\nusing  setCountryCode() .  $validator = new Zend\\Validator\\Iban(['country_code' =  'AT']);\n\nif ($validator- isValid('AT611904300234573201')) {\n    // IBAN appears to be valid\n} else {\n    // IBAN is not valid\n}", 
            "title": "Region aware IBAN validation"
        }, 
        {
            "location": "/validators/identical/", 
            "text": "Identical Validator\n\n\nZend\\Validator\\Identical\n allows you to validate if a given value is identical\nwith a set token.\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\Identical\n:\n\n\n\n\nstrict\n: Defines if the validation should be strict (i.e., if types should\n  also be considered). The default value is \ntrue\n.\n\n\ntoken\n: Sets the token against which the input will be validated.\n\n\nliteral\n: If set to \ntrue\n, the validation will skip the lookup for elements\n  in the form context, and validate the token just the way it was provided. The\n  default value is \nfalse\n.\n\n\n\n\nBasic usage\n\n\nTo validate if two values are identical, you need to set the original value as\nthe token, as demonstrated in the following example:\ntoken.\n\n\n$valid = new Zend\\Validator\\Identical('origin');\n\nif ($valid-\nisValid($value)) {\n    return true;\n}\n\n\n\n\nThe validation will only then return \ntrue\n when both values are 100% identical.\nIn our example, when \n$value\n is \n'origin'\n.\n\n\nYou can set the token after instantiation by using the method \nsetToken()\n.\n\n\nIdentical objects\n\n\nZend\\Validator\\Identical\n can validate not only strings, but any other variable\ntype, such as booleans, integers, floats, arrays, or even objects. As already\nnoted, the token and value must be identical.\n\n\n$valid = new Zend\\Validator\\Identical(123);\n\nif ($valid-\nisValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}\n\n\n\n\n\n\nType comparison\n\n\nYou should be aware of the variable type used for validation. This means that\nthe string \n'3'\n is not identical to integer \n3\n. When you want non-strict\nvalidation, you must set the \nstrict\n option to \nfalse\n.\n\n\n\n\nForm elements\n\n\nZend\\Validator\\Identical\n supports the comparison of form elements. This can be\ndone by using the element's name as the \ntoken\n:\n\n\n$form-\nadd([\n    'name' =\n 'elementOne',\n    'type' =\n 'Password',\n]);\n$form-\nadd([\n    'name'       =\n 'elementTwo',\n    'type'       =\n 'Password',\n    'validators' =\n [\n        [\n            'name'    =\n 'Identical',\n            'options' =\n [\n                'token' =\n 'elementOne',\n            ],\n        ],\n    ],\n]);\n\n\n\n\nBy using the element's name from the first element as the \ntoken\n for the second\nelement, the validator validates if the second element is equal with the first\nelement. In the case your user does not enter two identical values, you will get\na validation error.\n\n\nValidating a Value From a Fieldset\n\n\nSometimes you will need to validate an input that lives inside a fieldset, and\nthis can be accomplished as follows:\n\n\nuse Zend\\Form\\Element;\nuse Zend\\Form\\Fieldset;\nuse Zend\\Form\\Form;\nuse Zend\\InputFilter\\Input;\nuse Zend\\InputFilter\\InputFilter;\n\n$userFieldset = new Fieldset('user'); // (1)\n$userFieldset-\nadd([\n    'name' =\n 'email', // (2)\n    'type' =\n 'Email',\n]);\n\n// Let's add one fieldset inside the 'user' fieldset,\n// so we can see how to manage the token in a different deepness\n$deeperFieldset = new Fieldset('deeperFieldset'); // (3)\n$deeperFieldset-\nadd([\n    'name'    =\n 'deeperFieldsetInput', // (4)\n    'type'    =\n 'Text',\n    'options' =\n [\n        'label' =\n 'What validator are we testing?',\n    ],\n]);\n$userFieldset-\nadd($deeperFieldset);\n\n$signUpForm = new Form('signUp');\n$signUpForm-\nadd($userFieldset);\n\n// Add an input that will validate the 'email' input from 'user' fieldset\n$signUpForm-\nadd([\n    'name' =\n 'confirmEmail', // (5)\n    'type' =\n 'Email',\n]);\n\n// Add an input that will validate the 'deeperFieldsetInput' from\n// 'deeperFieldset' that lives inside the 'user' fieldset\n$signUpForm-\nadd([\n    'name' =\n 'confirmTestingValidator', // (6)\n    'type' =\n 'Text',\n]);\n\n// This will ensure the user enter the same email in 'email' (2) and\n// 'confirmEmail' (5)\n$inputFilter = new InputFilter();\n$inputFilter-\nadd([\n    'name' =\n 'confirmEmail', // references (5)\n    'validators' =\n [\n        [\n            'name' =\n 'Identical',\n            'options' =\n [\n                // 'user' key references 'user' fieldset (1), and 'email'\n                // references 'email' element inside 'user' fieldset (2)\n                'token' =\n ['user' =\n 'email'],\n            ],\n        ],\n    ],\n]);\n\n// This will ensure the user enter the same string in 'deeperFieldsetInput' (4)\n// and 'confirmTestingValidator' (6)\n$inputFilter-\nadd([\n    'name' =\n 'confirmTestingValidator', // references (6)\n    'validators' =\n [\n        [\n            'name' =\n 'Identical',\n            'options' =\n [\n                'token' =\n [\n                    'user' =\n [ // references 'user' fieldset (1)\n                        // 'deeperFieldset' key references 'deeperFieldset'\n                        // fieldset (3); 'deeperFieldsetInput' references\n                        // 'deeperFieldsetInput' element (4)\n                        'deeperFieldset' =\n 'deeperFieldsetInput',\n                    ],\n                ],\n            ],\n        ],\n    ],\n]);\n\n$signUpForm-\nsetInputFilter($inputFilter);\n\n\n\n\n\n\nUse one token per leaf\n\n\nAways make sure that your token array have just one key per level all the way\ntill the leaf, otherwise you can end up with unexpected results.\n\n\n\n\nStrict validation\n\n\nAs mentioned before, \nZend\\Validator\\Identical\n validates tokens using strict\ntyping. You can change this behaviour by using the \nstrict\n option. The default\nvalue for this property is \ntrue\n.\n\n\n$valid = new Zend\\Validator\\Identical(['token' =\n 123, 'strict' =\n false]);\n$input = '123';\nif ($valid-\nisValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}\n\n\n\n\nThe difference to the previous example is that the validation returns in this\ncase \ntrue\n, even if you compare a integer with string value as long as the\ncontent is identical but not the type.\n\n\nFor convenience you can also use \nsetStrict()\n and \ngetStrict()\n.\n\n\nConfiguration\n\n\nAs all other validators, \nZend\\Validator\\Identical\n also supports the usage of\nconfiguration settings during instantiation. This means that you can configure\nthis validator with a \nTraversable\n object.\n\n\nThere is a case which you should be aware of. If you are using an array as\ntoken, and it contains a \ntoken\n key, you should wrap it within another\n\ntoken\n key. See the examples below to undestand this situation.\n\n\n// This will not validate ['token' =\n 123], it will actually validate the\n// integer 123\n$valid = new Zend\\Validator\\Identical(['token' =\n 123]);\nif ($valid-\nisValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}\n\n\n\n\nThe reason for this special case is that you can configure the token which has\nto be used by giving the \ntoken\n key.\n\n\nSo, when you are using an array as the token, and it contains one element with a\n\ntoken\n key, then you have to wrap it as shown in the example below:\n\n\n// Unlike the previous example, this will validate ['token' =\n 123]\n$valid = new Zend\\Validator\\Identical(['token' =\n ['token' =\n 123]]);\nif ($valid-\nisValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}\n\n\n\n\nIf the array you are willing to validate does not have a \ntoken\n key, you do not\nneed to wrap it.", 
            "title": "Identical"
        }, 
        {
            "location": "/validators/identical/#identical-validator", 
            "text": "Zend\\Validator\\Identical  allows you to validate if a given value is identical\nwith a set token.", 
            "title": "Identical Validator"
        }, 
        {
            "location": "/validators/identical/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\Identical :   strict : Defines if the validation should be strict (i.e., if types should\n  also be considered). The default value is  true .  token : Sets the token against which the input will be validated.  literal : If set to  true , the validation will skip the lookup for elements\n  in the form context, and validate the token just the way it was provided. The\n  default value is  false .", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/identical/#basic-usage", 
            "text": "To validate if two values are identical, you need to set the original value as\nthe token, as demonstrated in the following example:\ntoken.  $valid = new Zend\\Validator\\Identical('origin');\n\nif ($valid- isValid($value)) {\n    return true;\n}  The validation will only then return  true  when both values are 100% identical.\nIn our example, when  $value  is  'origin' .  You can set the token after instantiation by using the method  setToken() .", 
            "title": "Basic usage"
        }, 
        {
            "location": "/validators/identical/#identical-objects", 
            "text": "Zend\\Validator\\Identical  can validate not only strings, but any other variable\ntype, such as booleans, integers, floats, arrays, or even objects. As already\nnoted, the token and value must be identical.  $valid = new Zend\\Validator\\Identical(123);\n\nif ($valid- isValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}", 
            "title": "Identical objects"
        }, 
        {
            "location": "/validators/identical/#type-comparison", 
            "text": "You should be aware of the variable type used for validation. This means that\nthe string  '3'  is not identical to integer  3 . When you want non-strict\nvalidation, you must set the  strict  option to  false .", 
            "title": "Type comparison"
        }, 
        {
            "location": "/validators/identical/#form-elements", 
            "text": "Zend\\Validator\\Identical  supports the comparison of form elements. This can be\ndone by using the element's name as the  token :  $form- add([\n    'name' =  'elementOne',\n    'type' =  'Password',\n]);\n$form- add([\n    'name'       =  'elementTwo',\n    'type'       =  'Password',\n    'validators' =  [\n        [\n            'name'    =  'Identical',\n            'options' =  [\n                'token' =  'elementOne',\n            ],\n        ],\n    ],\n]);  By using the element's name from the first element as the  token  for the second\nelement, the validator validates if the second element is equal with the first\nelement. In the case your user does not enter two identical values, you will get\na validation error.", 
            "title": "Form elements"
        }, 
        {
            "location": "/validators/identical/#validating-a-value-from-a-fieldset", 
            "text": "Sometimes you will need to validate an input that lives inside a fieldset, and\nthis can be accomplished as follows:  use Zend\\Form\\Element;\nuse Zend\\Form\\Fieldset;\nuse Zend\\Form\\Form;\nuse Zend\\InputFilter\\Input;\nuse Zend\\InputFilter\\InputFilter;\n\n$userFieldset = new Fieldset('user'); // (1)\n$userFieldset- add([\n    'name' =  'email', // (2)\n    'type' =  'Email',\n]);\n\n// Let's add one fieldset inside the 'user' fieldset,\n// so we can see how to manage the token in a different deepness\n$deeperFieldset = new Fieldset('deeperFieldset'); // (3)\n$deeperFieldset- add([\n    'name'    =  'deeperFieldsetInput', // (4)\n    'type'    =  'Text',\n    'options' =  [\n        'label' =  'What validator are we testing?',\n    ],\n]);\n$userFieldset- add($deeperFieldset);\n\n$signUpForm = new Form('signUp');\n$signUpForm- add($userFieldset);\n\n// Add an input that will validate the 'email' input from 'user' fieldset\n$signUpForm- add([\n    'name' =  'confirmEmail', // (5)\n    'type' =  'Email',\n]);\n\n// Add an input that will validate the 'deeperFieldsetInput' from\n// 'deeperFieldset' that lives inside the 'user' fieldset\n$signUpForm- add([\n    'name' =  'confirmTestingValidator', // (6)\n    'type' =  'Text',\n]);\n\n// This will ensure the user enter the same email in 'email' (2) and\n// 'confirmEmail' (5)\n$inputFilter = new InputFilter();\n$inputFilter- add([\n    'name' =  'confirmEmail', // references (5)\n    'validators' =  [\n        [\n            'name' =  'Identical',\n            'options' =  [\n                // 'user' key references 'user' fieldset (1), and 'email'\n                // references 'email' element inside 'user' fieldset (2)\n                'token' =  ['user' =  'email'],\n            ],\n        ],\n    ],\n]);\n\n// This will ensure the user enter the same string in 'deeperFieldsetInput' (4)\n// and 'confirmTestingValidator' (6)\n$inputFilter- add([\n    'name' =  'confirmTestingValidator', // references (6)\n    'validators' =  [\n        [\n            'name' =  'Identical',\n            'options' =  [\n                'token' =  [\n                    'user' =  [ // references 'user' fieldset (1)\n                        // 'deeperFieldset' key references 'deeperFieldset'\n                        // fieldset (3); 'deeperFieldsetInput' references\n                        // 'deeperFieldsetInput' element (4)\n                        'deeperFieldset' =  'deeperFieldsetInput',\n                    ],\n                ],\n            ],\n        ],\n    ],\n]);\n\n$signUpForm- setInputFilter($inputFilter);", 
            "title": "Validating a Value From a Fieldset"
        }, 
        {
            "location": "/validators/identical/#use-one-token-per-leaf", 
            "text": "Aways make sure that your token array have just one key per level all the way\ntill the leaf, otherwise you can end up with unexpected results.", 
            "title": "Use one token per leaf"
        }, 
        {
            "location": "/validators/identical/#strict-validation", 
            "text": "As mentioned before,  Zend\\Validator\\Identical  validates tokens using strict\ntyping. You can change this behaviour by using the  strict  option. The default\nvalue for this property is  true .  $valid = new Zend\\Validator\\Identical(['token' =  123, 'strict' =  false]);\n$input = '123';\nif ($valid- isValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}  The difference to the previous example is that the validation returns in this\ncase  true , even if you compare a integer with string value as long as the\ncontent is identical but not the type.  For convenience you can also use  setStrict()  and  getStrict() .", 
            "title": "Strict validation"
        }, 
        {
            "location": "/validators/identical/#configuration", 
            "text": "As all other validators,  Zend\\Validator\\Identical  also supports the usage of\nconfiguration settings during instantiation. This means that you can configure\nthis validator with a  Traversable  object.  There is a case which you should be aware of. If you are using an array as\ntoken, and it contains a  token  key, you should wrap it within another token  key. See the examples below to undestand this situation.  // This will not validate ['token' =  123], it will actually validate the\n// integer 123\n$valid = new Zend\\Validator\\Identical(['token' =  123]);\nif ($valid- isValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}  The reason for this special case is that you can configure the token which has\nto be used by giving the  token  key.  So, when you are using an array as the token, and it contains one element with a token  key, then you have to wrap it as shown in the example below:  // Unlike the previous example, this will validate ['token' =  123]\n$valid = new Zend\\Validator\\Identical(['token' =  ['token' =  123]]);\nif ($valid- isValid($input)) {\n    // input appears to be valid\n} else {\n    // input is invalid\n}  If the array you are willing to validate does not have a  token  key, you do not\nneed to wrap it.", 
            "title": "Configuration"
        }, 
        {
            "location": "/validators/in-array/", 
            "text": "InArray Validator\n\n\nZend\\Validator\\InArray\n allows you to validate if a given value is contained\nwithin an array. It is also able to validate multidimensional arrays.\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\InArray\n:\n\n\n\n\nhaystack\n: Sets the haystack for the validation. \n\n\nrecursive\n: Defines if the validation should be done recursively. This option\n  defaults to \nfalse\n.\n\n\nstrict\n: Three modes of comparison are offered owing to an often overlooked,\n  and potentially dangerous security issue when validating string input from\n  user input.\n\n\nInArray::COMPARE_STRICT\n: This is a normal \nin_array()\n strict comparison\n  that checks value and type.\n\n\nInArray::COMPARE_NOT_STRICT\n: This is a normal \nin_array()\n non-strict\n  comparison that checks value only, but not type.\n\n\nInArray::COMPARE_NOT_STRICT_AND_PREVENT_STR_TO_INT_VULNERABILTY\n: This\n  operates in essentially the same way as \nInArray::COMPARE_NOT_STRICT\n,\n  but ensures that strings are not cast to integer during comparison,\n  preventing \n0 == 'foo43'\n types of false positives.\n\n\n\n\n\n\n\n\n\n\nUse non-strict carefully\n\n\nNon-strict mode (\nInArray::COMPARE_NOT_STRICT\n) may give false positives when\nstrings are compared against ints or floats owing to \nin_array()\n's behaviour\nof converting strings to int in such cases. Therefore, \n'foo'\n would become\n\n0\n, \n'43foo'\n would become \n43\n, while \nfoo43'\n would also become \n0\n.\n\n\n\n\nArray validation\n\n\nBasic usage is to provide an array during instantiation:\n\n\n$validator = new Zend\\Validator\\InArray([\n    'haystack' =\n ['value1', 'value2',...'valueN'],\n]);\n\nif ($validator-\nisValid('value')) {\n    // value found\n} else {\n    // no value found\n}\n\n\n\n\nThis will behave exactly like PHP's \nin_array()\n method when passed only a\nneedle and haystack.\n\n\n\n\nNon-strict by default\n\n\nBy default, this validation is not strict, nor can it validate\nmultidimensional arrays.\n\n\n\n\nAlternately, you can define the array to validate against after object\nconstruction by using the \nsetHaystack()\n method. \ngetHaystack()\n returns the\nactual set haystack array.\n\n\n$validator = new Zend\\Validator\\InArray();\n$validator-\nsetHaystack(['value1', 'value2',...'valueN']);\n\nif ($validator-\nisValid('value')) {\n    // value found\n} else {\n    // no value found\n}\n\n\n\n\nArray validation modes\n\n\nAs previously mentioned, there are possible security issues when using the\ndefault non-strict comparison mode, so rather than restricting the developer,\nwe've chosen to offer both strict and non-strict comparisons, and add a safer\nmiddle-ground.\n\n\nIt's possible to set the strict mode at initialisation and afterwards with the\n\nsetStrict\n method. \nInArray::COMPARE_STRICT\n equates to \ntrue\n and\n\nInArray::COMPARE_NOT_STRICT_AND_PREVENT_STR_TO_INT_VULNERABILITY\n equates to\n\nfalse\n.\n\n\n// defaults to InArray::COMPARE_NOT_STRICT_AND_PREVENT_STR_TO_INT_VULNERABILITY\n$validator = new Zend\\Validator\\InArray([\n    'haystack' =\n ['value1', 'value2', /* ... */ 'valueN'],\n]);\n\n// set strict mode\n$validator = new Zend\\Validator\\InArray([\n    'haystack' =\n ['value1', 'value2', /* ... */ 'valueN'],\n    'strict'   =\n InArray::COMPARE_STRICT,  // equates to ``true``\n]);\n\n// set non-strict mode  \n$validator = new Zend\\Validator\\InArray([\n    'haystack' =\n ['value1', 'value2', /* ... */ 'valueN'],\n    'strict'   =\n InArray:COMPARE_NOT_STRICT,  // equates to ``false``\n]);\n\n// or\n\n$validator-\nsetStrict(InArray::COMPARE_STRICT); \n$validator-\nsetStrict(InArray::COMPARE_NOT_STRICT);\n$validator-\nsetStrict(InArray::COMPARE_NOT_STRICT_AND_PREVENT_STR_TO_INT_VULNERABILITY);\n\n\n\n\n\n\nNon-strict safe-mode by default\n\n\nNote that the \nstrict\n setting is per default \nfalse\n.\n\n\n\n\nRecursive array validation\n\n\nIn addition to PHP's \nin_array()\n method, this validator can also be used to\nvalidate multidimensional arrays.\n\n\nTo validate multidimensional arrays you have to set the \nrecursive\n option.\n\n\n$validator = new Zend\\Validator\\InArray([\n    'haystack' =\n [\n        'firstDimension' =\n ['value1', 'value2', / ... */ 'valueN'],\n        'secondDimension' =\n ['foo1', 'foo2', /* ... */ 'fooN'],\n    ],\n    'recursive' =\n true,\n]);\n\nif ($validator-\nisValid('value')) {\n    // value found\n} else {\n    // no value found\n}\n\n\n\n\nYour array will then be validated recursively to see if the given value is\ncontained. Additionally you could use \nsetRecursive()\n to set this option\nafterwards and \ngetRecursive()\n to retrieve it.\n\n\n$validator = new Zend\\Validator\\InArray([\n    'firstDimension' =\n ['value1', 'value2', /* ... */ 'valueN'],\n    'secondDimension' =\n ['foo1', 'foo2', /* ... */ 'fooN'],\n]);\n\n$validator-\nsetRecursive(true);\n\nif ($validator-\nisValid('value')) {\n    // value found\n} else {\n    // no value found\n}\n\n\n\n\n\n\nDefault setting for recursion\n\n\nBy default, the recursive validation is turned off.\n\n\nOption keys within the haystack\n\n\nWhen you are using the keys \nhaystack\n, \nstrict\n, or \nrecursive\n within\nyour haystack, then you must wrap the \nhaystack\n key.", 
            "title": "InArray"
        }, 
        {
            "location": "/validators/in-array/#inarray-validator", 
            "text": "Zend\\Validator\\InArray  allows you to validate if a given value is contained\nwithin an array. It is also able to validate multidimensional arrays.", 
            "title": "InArray Validator"
        }, 
        {
            "location": "/validators/in-array/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\InArray :   haystack : Sets the haystack for the validation.   recursive : Defines if the validation should be done recursively. This option\n  defaults to  false .  strict : Three modes of comparison are offered owing to an often overlooked,\n  and potentially dangerous security issue when validating string input from\n  user input.  InArray::COMPARE_STRICT : This is a normal  in_array()  strict comparison\n  that checks value and type.  InArray::COMPARE_NOT_STRICT : This is a normal  in_array()  non-strict\n  comparison that checks value only, but not type.  InArray::COMPARE_NOT_STRICT_AND_PREVENT_STR_TO_INT_VULNERABILTY : This\n  operates in essentially the same way as  InArray::COMPARE_NOT_STRICT ,\n  but ensures that strings are not cast to integer during comparison,\n  preventing  0 == 'foo43'  types of false positives.", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/in-array/#use-non-strict-carefully", 
            "text": "Non-strict mode ( InArray::COMPARE_NOT_STRICT ) may give false positives when\nstrings are compared against ints or floats owing to  in_array() 's behaviour\nof converting strings to int in such cases. Therefore,  'foo'  would become 0 ,  '43foo'  would become  43 , while  foo43'  would also become  0 .", 
            "title": "Use non-strict carefully"
        }, 
        {
            "location": "/validators/in-array/#array-validation", 
            "text": "Basic usage is to provide an array during instantiation:  $validator = new Zend\\Validator\\InArray([\n    'haystack' =  ['value1', 'value2',...'valueN'],\n]);\n\nif ($validator- isValid('value')) {\n    // value found\n} else {\n    // no value found\n}  This will behave exactly like PHP's  in_array()  method when passed only a\nneedle and haystack.", 
            "title": "Array validation"
        }, 
        {
            "location": "/validators/in-array/#non-strict-by-default", 
            "text": "By default, this validation is not strict, nor can it validate\nmultidimensional arrays.   Alternately, you can define the array to validate against after object\nconstruction by using the  setHaystack()  method.  getHaystack()  returns the\nactual set haystack array.  $validator = new Zend\\Validator\\InArray();\n$validator- setHaystack(['value1', 'value2',...'valueN']);\n\nif ($validator- isValid('value')) {\n    // value found\n} else {\n    // no value found\n}", 
            "title": "Non-strict by default"
        }, 
        {
            "location": "/validators/in-array/#array-validation-modes", 
            "text": "As previously mentioned, there are possible security issues when using the\ndefault non-strict comparison mode, so rather than restricting the developer,\nwe've chosen to offer both strict and non-strict comparisons, and add a safer\nmiddle-ground.  It's possible to set the strict mode at initialisation and afterwards with the setStrict  method.  InArray::COMPARE_STRICT  equates to  true  and InArray::COMPARE_NOT_STRICT_AND_PREVENT_STR_TO_INT_VULNERABILITY  equates to false .  // defaults to InArray::COMPARE_NOT_STRICT_AND_PREVENT_STR_TO_INT_VULNERABILITY\n$validator = new Zend\\Validator\\InArray([\n    'haystack' =  ['value1', 'value2', /* ... */ 'valueN'],\n]);\n\n// set strict mode\n$validator = new Zend\\Validator\\InArray([\n    'haystack' =  ['value1', 'value2', /* ... */ 'valueN'],\n    'strict'   =  InArray::COMPARE_STRICT,  // equates to ``true``\n]);\n\n// set non-strict mode  \n$validator = new Zend\\Validator\\InArray([\n    'haystack' =  ['value1', 'value2', /* ... */ 'valueN'],\n    'strict'   =  InArray:COMPARE_NOT_STRICT,  // equates to ``false``\n]);\n\n// or\n\n$validator- setStrict(InArray::COMPARE_STRICT); \n$validator- setStrict(InArray::COMPARE_NOT_STRICT);\n$validator- setStrict(InArray::COMPARE_NOT_STRICT_AND_PREVENT_STR_TO_INT_VULNERABILITY);", 
            "title": "Array validation modes"
        }, 
        {
            "location": "/validators/in-array/#non-strict-safe-mode-by-default", 
            "text": "Note that the  strict  setting is per default  false .", 
            "title": "Non-strict safe-mode by default"
        }, 
        {
            "location": "/validators/in-array/#recursive-array-validation", 
            "text": "In addition to PHP's  in_array()  method, this validator can also be used to\nvalidate multidimensional arrays.  To validate multidimensional arrays you have to set the  recursive  option.  $validator = new Zend\\Validator\\InArray([\n    'haystack' =  [\n        'firstDimension' =  ['value1', 'value2', / ... */ 'valueN'],\n        'secondDimension' =  ['foo1', 'foo2', /* ... */ 'fooN'],\n    ],\n    'recursive' =  true,\n]);\n\nif ($validator- isValid('value')) {\n    // value found\n} else {\n    // no value found\n}  Your array will then be validated recursively to see if the given value is\ncontained. Additionally you could use  setRecursive()  to set this option\nafterwards and  getRecursive()  to retrieve it.  $validator = new Zend\\Validator\\InArray([\n    'firstDimension' =  ['value1', 'value2', /* ... */ 'valueN'],\n    'secondDimension' =  ['foo1', 'foo2', /* ... */ 'fooN'],\n]);\n\n$validator- setRecursive(true);\n\nif ($validator- isValid('value')) {\n    // value found\n} else {\n    // no value found\n}", 
            "title": "Recursive array validation"
        }, 
        {
            "location": "/validators/in-array/#default-setting-for-recursion", 
            "text": "By default, the recursive validation is turned off.", 
            "title": "Default setting for recursion"
        }, 
        {
            "location": "/validators/in-array/#option-keys-within-the-haystack", 
            "text": "When you are using the keys  haystack ,  strict , or  recursive  within\nyour haystack, then you must wrap the  haystack  key.", 
            "title": "Option keys within the haystack"
        }, 
        {
            "location": "/validators/ip/", 
            "text": "Ip Validator\n\n\nZend\\Validator\\Ip\n allows you to validate if a given value is an IP address. It\nsupports the IPv4, IPv6, and IPvFuture definitions.\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\Ip\n:\n\n\n\n\nallowipv4\n: Defines if the validator allows IPv4 addresses. This option\n  defaults to \ntrue\n.\n\n\nallowipv6\n: Defines if the validator allows IPv6 addresses. This option\n  defaults to \ntrue\n.\n\n\nallowipvfuture\n: Defines if the validator allows IPvFuture addresses. This\n  option defaults to \nfalse\n.\n\n\nallowliteral\n: Defines if the validator allows IPv6 or IPvFuture with URI\n  literal style (the IP surrounded by brackets). This option defaults to \ntrue\n.\n\n\n\n\nBasic usage\n\n\n$validator = new Zend\\Validator\\Ip();\n\nif ($validator-\nisValid($ip)) {\n    // ip appears to be valid\n} else {\n    // ip is invalid; print the reasons\n}\n\n\n\n\n\n\nInvalid IP addresses\n\n\nKeep in mind that \nZend\\Validator\\Ip\n only validates IP addresses. Addresses\nlike '\nmydomain.com\n' or '\n192.168.50.1/index.html\n' are not valid IP\naddresses. They are either hostnames or valid URLs but not IP addresses.\n\n\nIPv6/IPvFuture validation\n\n\nZend\\Validator\\Ip\n validates IPv6/IPvFuture addresses using a regex. The\nreason is that the filters and methods from PHP itself don't follow the RFC.\nMany other available classes also don't follow it.\n\n\n\n\nValidate IPv4 or IPV6 alone\n\n\nSometimes it's useful to validate only one of the supported formats; e.g., when\nyour network only supports IPv4. In this case it would be useless to allow IPv6\nwithin this validator.\n\n\nTo limit \nZend\\Validator\\Ip\n to one protocol, you can set the options \nallowipv4\n\nor \nallowipv6\n to \nfalse\n. You can do this either by giving the option to the\nconstructor or by using \nsetOptions()\n afterwards.\n\n\n$validator = new Zend\\Validator\\Ip(['allowipv6' =\n false]);\n\nif ($validator-\nisValid($ip)) {\n    // ip appears to be valid ipv4 address\n} else {\n    // ip is not an ipv4 address\n}\n\n\n\n\n\n\nDefault behaviour\n\n\nThe default behaviour which \nZend\\Validator\\Ip\n follows is to allow both\nstandards.", 
            "title": "Ip"
        }, 
        {
            "location": "/validators/ip/#ip-validator", 
            "text": "Zend\\Validator\\Ip  allows you to validate if a given value is an IP address. It\nsupports the IPv4, IPv6, and IPvFuture definitions.", 
            "title": "Ip Validator"
        }, 
        {
            "location": "/validators/ip/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\Ip :   allowipv4 : Defines if the validator allows IPv4 addresses. This option\n  defaults to  true .  allowipv6 : Defines if the validator allows IPv6 addresses. This option\n  defaults to  true .  allowipvfuture : Defines if the validator allows IPvFuture addresses. This\n  option defaults to  false .  allowliteral : Defines if the validator allows IPv6 or IPvFuture with URI\n  literal style (the IP surrounded by brackets). This option defaults to  true .", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/ip/#basic-usage", 
            "text": "$validator = new Zend\\Validator\\Ip();\n\nif ($validator- isValid($ip)) {\n    // ip appears to be valid\n} else {\n    // ip is invalid; print the reasons\n}", 
            "title": "Basic usage"
        }, 
        {
            "location": "/validators/ip/#invalid-ip-addresses", 
            "text": "Keep in mind that  Zend\\Validator\\Ip  only validates IP addresses. Addresses\nlike ' mydomain.com ' or ' 192.168.50.1/index.html ' are not valid IP\naddresses. They are either hostnames or valid URLs but not IP addresses.", 
            "title": "Invalid IP addresses"
        }, 
        {
            "location": "/validators/ip/#ipv6ipvfuture-validation", 
            "text": "Zend\\Validator\\Ip  validates IPv6/IPvFuture addresses using a regex. The\nreason is that the filters and methods from PHP itself don't follow the RFC.\nMany other available classes also don't follow it.", 
            "title": "IPv6/IPvFuture validation"
        }, 
        {
            "location": "/validators/ip/#validate-ipv4-or-ipv6-alone", 
            "text": "Sometimes it's useful to validate only one of the supported formats; e.g., when\nyour network only supports IPv4. In this case it would be useless to allow IPv6\nwithin this validator.  To limit  Zend\\Validator\\Ip  to one protocol, you can set the options  allowipv4 \nor  allowipv6  to  false . You can do this either by giving the option to the\nconstructor or by using  setOptions()  afterwards.  $validator = new Zend\\Validator\\Ip(['allowipv6' =  false]);\n\nif ($validator- isValid($ip)) {\n    // ip appears to be valid ipv4 address\n} else {\n    // ip is not an ipv4 address\n}", 
            "title": "Validate IPv4 or IPV6 alone"
        }, 
        {
            "location": "/validators/ip/#default-behaviour", 
            "text": "The default behaviour which  Zend\\Validator\\Ip  follows is to allow both\nstandards.", 
            "title": "Default behaviour"
        }, 
        {
            "location": "/validators/isbn/", 
            "text": "Isbn Validator\n\n\nZend\\Validator\\Isbn\n allows you to validate an ISBN-10 or ISBN-13 value.\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\Isbn\n:\n\n\n\n\nseparator\n: Defines the allowed separator for the ISBN number. It defaults to\n  an empty string.\n\n\ntype\n: Defines the allowed ISBN types. It defaults to\n  \nZend\\Validator\\Isbn::AUTO\n. For details, take a look at the section on\n  \nexplicit types\n.\n\n\n\n\nBasic usage\n\n\nA basic example of usage is below:\n\n\n$validator = new Zend\\Validator\\Isbn();\n\nif ($validator-\nisValid($isbn)) {\n    // isbn is valid\n} else {\n    // isbn is not valid\n}\n\n\n\n\nThis will validate any ISBN-10 and ISBN-13 without separator.\n\n\nSetting an explicit ISBN validation type\n\n\nAn example of an ISBN type restriction follows:\n\n\nuse Zend\\Validator\\Isbn;\n\n$validator = new Isbn();\n$validator-\nsetType(Isbn::ISBN13);\n\n// OR\n$validator = new Isbn([ 'type' =\n Isbn::ISBN13]);\n\nif ($validator-\nisValid($isbn)) {\n    // this is a valid ISBN-13 value\n} else {\n    // this is an invalid ISBN-13 value\n}\n\n\n\n\nThe above will validate only ISBN-13 values.\n\n\nValid types include:\n\n\n\n\nZend\\Validator\\Isbn::AUTO\n (default)\n\n\nZend\\Validator\\Isbn::ISBN10\n\n\nZend\\Validator\\Isbn::ISBN13\n\n\n\n\nSpecifying a separator restriction\n\n\nAn example of separator restriction:\n\n\n$validator = new Zend\\Validator\\Isbn();\n$validator-\nsetSeparator('-');\n\n// OR\n$validator = new Zend\\Validator\\Isbn(['separator' =\n '-']);\n\nif ($validator-\nisValid($isbn)) {\n    // this is a valid ISBN with separator\n} else {\n    // this is an invalid ISBN with separator\n}\n\n\n\n\n\n\nValues without separators\n\n\nThis will return \nfalse\n if \n$isbn\n doesn't contain a separator \nor\n if it's\nan invalid \nISBN\n value.\n\n\n\n\nValid separators include:\n\n\n\n\n`` (empty) (default)\n\n\n-\n (hyphen)\n\n\n (space)", 
            "title": "Isbn"
        }, 
        {
            "location": "/validators/isbn/#isbn-validator", 
            "text": "Zend\\Validator\\Isbn  allows you to validate an ISBN-10 or ISBN-13 value.", 
            "title": "Isbn Validator"
        }, 
        {
            "location": "/validators/isbn/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\Isbn :   separator : Defines the allowed separator for the ISBN number. It defaults to\n  an empty string.  type : Defines the allowed ISBN types. It defaults to\n   Zend\\Validator\\Isbn::AUTO . For details, take a look at the section on\n   explicit types .", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/isbn/#basic-usage", 
            "text": "A basic example of usage is below:  $validator = new Zend\\Validator\\Isbn();\n\nif ($validator- isValid($isbn)) {\n    // isbn is valid\n} else {\n    // isbn is not valid\n}  This will validate any ISBN-10 and ISBN-13 without separator.", 
            "title": "Basic usage"
        }, 
        {
            "location": "/validators/isbn/#setting-an-explicit-isbn-validation-type", 
            "text": "An example of an ISBN type restriction follows:  use Zend\\Validator\\Isbn;\n\n$validator = new Isbn();\n$validator- setType(Isbn::ISBN13);\n\n// OR\n$validator = new Isbn([ 'type' =  Isbn::ISBN13]);\n\nif ($validator- isValid($isbn)) {\n    // this is a valid ISBN-13 value\n} else {\n    // this is an invalid ISBN-13 value\n}  The above will validate only ISBN-13 values.  Valid types include:   Zend\\Validator\\Isbn::AUTO  (default)  Zend\\Validator\\Isbn::ISBN10  Zend\\Validator\\Isbn::ISBN13", 
            "title": "Setting an explicit ISBN validation type"
        }, 
        {
            "location": "/validators/isbn/#specifying-a-separator-restriction", 
            "text": "An example of separator restriction:  $validator = new Zend\\Validator\\Isbn();\n$validator- setSeparator('-');\n\n// OR\n$validator = new Zend\\Validator\\Isbn(['separator' =  '-']);\n\nif ($validator- isValid($isbn)) {\n    // this is a valid ISBN with separator\n} else {\n    // this is an invalid ISBN with separator\n}", 
            "title": "Specifying a separator restriction"
        }, 
        {
            "location": "/validators/isbn/#values-without-separators", 
            "text": "This will return  false  if  $isbn  doesn't contain a separator  or  if it's\nan invalid  ISBN  value.   Valid separators include:   `` (empty) (default)  -  (hyphen)   (space)", 
            "title": "Values without separators"
        }, 
        {
            "location": "/validators/is-countable/", 
            "text": "IsCountable Validator\n\n\n\n\nSince 2.10.0\n\n\n\n\nZend\\Validator\\IsCountable\n allows you to validate that a value can be counted\n(i.e., it's an array or implements \nCountable\n), and, optionally:\n\n\n\n\nthe exact count of the value\n\n\nthe minimum count of the value\n\n\nthe maximum count of the value\n\n\n\n\nSpecifying either of the latter two is inconsistent with the first, and, as\nsuch, the validator does not allow setting both a count and a minimum or maximum\nvalue. You may, however specify both minimum and maximum values, in which case\nthe validator operates similar to the \nBetween validator\n.\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\IsCountable\n:\n\n\n\n\ncount\n: Defines if the validation should look for a specific, exact count for\n  the value provided.\n\n\nmax\n: Sets the maximum value for the validation; if the count of the value is\n  greater than the maximum, validation fails..\n\n\nmin\n: Sets the minimum value for the validation; if the count of the value is\n  lower than the minimum, validation fails.\n\n\n\n\nDefault behaviour\n\n\nGiven no options, the validator simply tests to see that the value may be\ncounted (i.e., it's an array or \nCountable\n instance):\n\n\n$validator = new Zend\\Validator\\IsCountable();\n\n$validator-\nisValid(10);                    // false; not an array or Countable\n$validator-\nisValid([10]);                  // true; value is an array\n$validator-\nisValid(new ArrayObject([10])); // true; value is Countable\n$validator-\nisValid(new stdClass);          // false; value is not Countable\n\n\n\n\nSpecifying an exact count\n\n\nYou can also specify an exact count; if the value is countable, and its count\nmatches, the the value is valid.\n\n\n$validator = new Zend\\Validator\\IsCountable(['count' =\n 3]);\n\n$validator-\nisValid([1, 2, 3]);                  // true; countable, and count is 3\n$validator-\nisValid(new ArrayObject([1, 2, 3])); // true; countable, and count is 3\n$validator-\nisValid([1]);                        // false; countable, but count is 1\n$validator-\nisValid(new ArrayObject([1]));       // false; countable, but count is 1\n\n\n\n\nSpecifying a minimum count\n\n\nYou may specify a minimum count. When you do, the value must be countable, and\ngreater than or equal to the minimum count you specify in order to be valid.\n\n\n$validator = new Zend\\Validator\\IsCountable(['min' =\n 2]);\n\n$validator-\nisValid([1, 2, 3]);                  // true; countable, and count is 3\n$validator-\nisValid(new ArrayObject([1, 2, 3])); // true; countable, and count is 3\n$validator-\nisValid([1, 2]);                     // true; countable, and count is 2\n$validator-\nisValid(new ArrayObject([1, 2]));    // true; countable, and count is 2\n$validator-\nisValid([1]);                        // false; countable, but count is 1\n$validator-\nisValid(new ArrayObject([1]));       // false; countable, but count is 1\n\n\n\n\nSpecifying a maximum count\n\n\nYou may specify a maximum count. When you do, the value must be countable, and\nless than or equal to the maximum count you specify in order to be valid.\n\n\n$validator = new Zend\\Validator\\IsCountable(['max' =\n 2]);\n\n$validator-\nisValid([1, 2, 3]);                  // false; countable, but count is 3\n$validator-\nisValid(new ArrayObject([1, 2, 3])); // false; countable, but count is 3\n$validator-\nisValid([1, 2]);                     // true; countable, and count is 2\n$validator-\nisValid(new ArrayObject([1, 2]));    // true; countable, and count is 2\n$validator-\nisValid([1]);                        // true; countable, and count is 1\n$validator-\nisValid(new ArrayObject([1]));       // true; countable, and count is 1\n\n\n\n\nSpecifying both minimum and maximum\n\n\nIf you specify both a minimum and maximum, the count must be \nbetween\n the two,\ninclusively (i.e., it may be the minimum or maximum, and any value between).\n\n\n$validator = new Zend\\Validator\\IsCountable([\n    'min' =\n 3,\n    'max' =\n 5,\n]);\n\n$validator-\nisValid([1, 2, 3]);                    // true; countable, and count is 3\n$validator-\nisValid(new ArrayObject([1, 2, 3]));   // true; countable, and count is 3\n$validator-\nisValid(range(1, 5));                  // true; countable, and count is 5\n$validator-\nisValid(new ArrayObject(range(1, 5))); // true; countable, and count is 5\n$validator-\nisValid([1, 2]);                       // false; countable, and count is 2\n$validator-\nisValid(new ArrayObject([1, 2]));      // false; countable, and count is 2\n$validator-\nisValid(range(1, 6));                  // false; countable, and count is 6\n$validator-\nisValid(new ArrayObject(range(1, 6))); // false; countable, and count is 6", 
            "title": "IsCountable"
        }, 
        {
            "location": "/validators/is-countable/#iscountable-validator", 
            "text": "Since 2.10.0   Zend\\Validator\\IsCountable  allows you to validate that a value can be counted\n(i.e., it's an array or implements  Countable ), and, optionally:   the exact count of the value  the minimum count of the value  the maximum count of the value   Specifying either of the latter two is inconsistent with the first, and, as\nsuch, the validator does not allow setting both a count and a minimum or maximum\nvalue. You may, however specify both minimum and maximum values, in which case\nthe validator operates similar to the  Between validator .", 
            "title": "IsCountable Validator"
        }, 
        {
            "location": "/validators/is-countable/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\IsCountable :   count : Defines if the validation should look for a specific, exact count for\n  the value provided.  max : Sets the maximum value for the validation; if the count of the value is\n  greater than the maximum, validation fails..  min : Sets the minimum value for the validation; if the count of the value is\n  lower than the minimum, validation fails.", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/is-countable/#default-behaviour", 
            "text": "Given no options, the validator simply tests to see that the value may be\ncounted (i.e., it's an array or  Countable  instance):  $validator = new Zend\\Validator\\IsCountable();\n\n$validator- isValid(10);                    // false; not an array or Countable\n$validator- isValid([10]);                  // true; value is an array\n$validator- isValid(new ArrayObject([10])); // true; value is Countable\n$validator- isValid(new stdClass);          // false; value is not Countable", 
            "title": "Default behaviour"
        }, 
        {
            "location": "/validators/is-countable/#specifying-an-exact-count", 
            "text": "You can also specify an exact count; if the value is countable, and its count\nmatches, the the value is valid.  $validator = new Zend\\Validator\\IsCountable(['count' =  3]);\n\n$validator- isValid([1, 2, 3]);                  // true; countable, and count is 3\n$validator- isValid(new ArrayObject([1, 2, 3])); // true; countable, and count is 3\n$validator- isValid([1]);                        // false; countable, but count is 1\n$validator- isValid(new ArrayObject([1]));       // false; countable, but count is 1", 
            "title": "Specifying an exact count"
        }, 
        {
            "location": "/validators/is-countable/#specifying-a-minimum-count", 
            "text": "You may specify a minimum count. When you do, the value must be countable, and\ngreater than or equal to the minimum count you specify in order to be valid.  $validator = new Zend\\Validator\\IsCountable(['min' =  2]);\n\n$validator- isValid([1, 2, 3]);                  // true; countable, and count is 3\n$validator- isValid(new ArrayObject([1, 2, 3])); // true; countable, and count is 3\n$validator- isValid([1, 2]);                     // true; countable, and count is 2\n$validator- isValid(new ArrayObject([1, 2]));    // true; countable, and count is 2\n$validator- isValid([1]);                        // false; countable, but count is 1\n$validator- isValid(new ArrayObject([1]));       // false; countable, but count is 1", 
            "title": "Specifying a minimum count"
        }, 
        {
            "location": "/validators/is-countable/#specifying-a-maximum-count", 
            "text": "You may specify a maximum count. When you do, the value must be countable, and\nless than or equal to the maximum count you specify in order to be valid.  $validator = new Zend\\Validator\\IsCountable(['max' =  2]);\n\n$validator- isValid([1, 2, 3]);                  // false; countable, but count is 3\n$validator- isValid(new ArrayObject([1, 2, 3])); // false; countable, but count is 3\n$validator- isValid([1, 2]);                     // true; countable, and count is 2\n$validator- isValid(new ArrayObject([1, 2]));    // true; countable, and count is 2\n$validator- isValid([1]);                        // true; countable, and count is 1\n$validator- isValid(new ArrayObject([1]));       // true; countable, and count is 1", 
            "title": "Specifying a maximum count"
        }, 
        {
            "location": "/validators/is-countable/#specifying-both-minimum-and-maximum", 
            "text": "If you specify both a minimum and maximum, the count must be  between  the two,\ninclusively (i.e., it may be the minimum or maximum, and any value between).  $validator = new Zend\\Validator\\IsCountable([\n    'min' =  3,\n    'max' =  5,\n]);\n\n$validator- isValid([1, 2, 3]);                    // true; countable, and count is 3\n$validator- isValid(new ArrayObject([1, 2, 3]));   // true; countable, and count is 3\n$validator- isValid(range(1, 5));                  // true; countable, and count is 5\n$validator- isValid(new ArrayObject(range(1, 5))); // true; countable, and count is 5\n$validator- isValid([1, 2]);                       // false; countable, and count is 2\n$validator- isValid(new ArrayObject([1, 2]));      // false; countable, and count is 2\n$validator- isValid(range(1, 6));                  // false; countable, and count is 6\n$validator- isValid(new ArrayObject(range(1, 6))); // false; countable, and count is 6", 
            "title": "Specifying both minimum and maximum"
        }, 
        {
            "location": "/validators/isinstanceof/", 
            "text": "IsInstanceOf Validator\n\n\nZend\\Validator\\IsInstanceOf\n allows you to validate whether a given object is\nan instance of a specific class or interface.\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\IsInstanceOf\n:\n\n\n\n\nclassName\n: Defines the fully-qualified class name which objects must be an\n  instance of.\n\n\n\n\nBasic usage\n\n\n$validator = new Zend\\Validator\\IsInstanceOf([\n    'className' =\n 'Zend\\Validator\\Digits'\n]);\n$object = new Zend\\Validator\\Digits();\n\nif ($validator-\nisValid($object)) {\n    // $object is an instance of Zend\\Validator\\Digits\n} else {\n    // false. You can use $validator-\ngetMessages() to retrieve error messages\n}\n\n\n\n\nIf a string argument is passed to the constructor of\n\nZend\\Validator\\IsInstanceOf\n, then that value will be used as the class name:\n\n\nuse Zend\\Validator\\Digits;\nuse Zend\\Validator\\IsInstanceOf;\n\n$validator = new IsInstanceOf(Digits::class);\n$object = new Digits();\n\nif ($validator-\nisValid($object)) {\n    // $object is an instance of Zend\\Validator\\Digits\n} else {\n    // false. You can use $validator-\ngetMessages() to retrieve error messages\n}", 
            "title": "IsInstanceOf"
        }, 
        {
            "location": "/validators/isinstanceof/#isinstanceof-validator", 
            "text": "Zend\\Validator\\IsInstanceOf  allows you to validate whether a given object is\nan instance of a specific class or interface.", 
            "title": "IsInstanceOf Validator"
        }, 
        {
            "location": "/validators/isinstanceof/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\IsInstanceOf :   className : Defines the fully-qualified class name which objects must be an\n  instance of.", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/isinstanceof/#basic-usage", 
            "text": "$validator = new Zend\\Validator\\IsInstanceOf([\n    'className' =  'Zend\\Validator\\Digits'\n]);\n$object = new Zend\\Validator\\Digits();\n\nif ($validator- isValid($object)) {\n    // $object is an instance of Zend\\Validator\\Digits\n} else {\n    // false. You can use $validator- getMessages() to retrieve error messages\n}  If a string argument is passed to the constructor of Zend\\Validator\\IsInstanceOf , then that value will be used as the class name:  use Zend\\Validator\\Digits;\nuse Zend\\Validator\\IsInstanceOf;\n\n$validator = new IsInstanceOf(Digits::class);\n$object = new Digits();\n\nif ($validator- isValid($object)) {\n    // $object is an instance of Zend\\Validator\\Digits\n} else {\n    // false. You can use $validator- getMessages() to retrieve error messages\n}", 
            "title": "Basic usage"
        }, 
        {
            "location": "/validators/less-than/", 
            "text": "LessThan Validator\n\n\nZend\\Validator\\LessThan\n allows you to validate if a given value is less than a\nmaximum value.\n\n\n\n\nSupports only number validation\n\n\nZend\\Validator\\LessThan\n supports only the validation of numbers. Strings or\ndates can not be validated with this validator.\n\n\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\LessThan\n:\n\n\n\n\ninclusive\n: Defines if the validation is inclusive the maximum value or\n  exclusive. It defaults to \nfalse\n.\n\n\nmax\n: Sets the maximum allowed value.\n\n\n\n\nBasic usage\n\n\nTo validate if a given value is less than a defined maximum:\n\n\n$valid  = new Zend\\Validator\\LessThan(['max' =\n 10]);\n$value  = 12;\n$return = $valid-\nisValid($value);\n// returns false\n\n\n\n\nThe above example returns \ntrue\n for all values lower than 10.\n\n\nInclusive validation\n\n\nSometimes it is useful to validate a value by including the maximum value:\n\n\n$valid  = new Zend\\Validator\\LessThan([\n    'max' =\n 10,\n    'inclusive' =\n true,\n]);\n$value  = 10;\n$result = $valid-\nisValid($value);\n// returns true\n\n\n\n\nThe example is identical to our first example, with the exception that we've\nspecified that the maximum is inclusive. Now the value '10' is allowed and will\nreturn \ntrue\n.", 
            "title": "LessThan"
        }, 
        {
            "location": "/validators/less-than/#lessthan-validator", 
            "text": "Zend\\Validator\\LessThan  allows you to validate if a given value is less than a\nmaximum value.   Supports only number validation  Zend\\Validator\\LessThan  supports only the validation of numbers. Strings or\ndates can not be validated with this validator.", 
            "title": "LessThan Validator"
        }, 
        {
            "location": "/validators/less-than/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\LessThan :   inclusive : Defines if the validation is inclusive the maximum value or\n  exclusive. It defaults to  false .  max : Sets the maximum allowed value.", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/less-than/#basic-usage", 
            "text": "To validate if a given value is less than a defined maximum:  $valid  = new Zend\\Validator\\LessThan(['max' =  10]);\n$value  = 12;\n$return = $valid- isValid($value);\n// returns false  The above example returns  true  for all values lower than 10.", 
            "title": "Basic usage"
        }, 
        {
            "location": "/validators/less-than/#inclusive-validation", 
            "text": "Sometimes it is useful to validate a value by including the maximum value:  $valid  = new Zend\\Validator\\LessThan([\n    'max' =  10,\n    'inclusive' =  true,\n]);\n$value  = 10;\n$result = $valid- isValid($value);\n// returns true  The example is identical to our first example, with the exception that we've\nspecified that the maximum is inclusive. Now the value '10' is allowed and will\nreturn  true .", 
            "title": "Inclusive validation"
        }, 
        {
            "location": "/validators/not-empty/", 
            "text": "NotEmpty Validator\n\n\nThis validator allows you to validate if a given value is not empty. This is\noften useful when working with form elements or other user input, where you can\nuse it to ensure required elements have values associated with them.\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\NotEmpty\n:\n\n\n\n\ntype\n: Sets the type of validation which will be processed; for details, see\n  the section on \nspecifying empty behavior\n.\n\n\n\n\nDefault behaviour\n\n\nBy default, this validator works differently than you would expect when you've\nworked with PHP's \nempty()\n operator. In particular, this validator will\nevaluate both the integer \n0\n and string \n'0'\n as empty.\n\n\n$valid = new Zend\\Validator\\NotEmpty();\n$value  = '';\n$result = $valid-\nisValid($value);\n// returns false\n\n\n\n\nSpecifying empty behavior\n\n\nSome projects have differing opinions of what is considered an \"empty\" value: a\nstring with only whitespace might be considered empty, or \n0\n may be\nconsidered non-empty (particularly for boolean sequences). To accommodate\ndiffering needs, \nZend\\Validator\\NotEmpty\n allows you to configure which types\nshould be validated as empty and which not.\n\n\nThe following types can be handled:\n\n\n\n\nboolean\n: Returns \nfalse\n when the boolean value is \nfalse\n.\n\n\ninteger\n: Returns \nfalse\n when an integer \n0\n value is given. By default,\n  this validation is not activate and returns \ntrue\n for any integer values.\n\n\nfloat\n: Returns \nfalse\n when a float \n0.0\n value is given. By default, this\n  validation is not activate and returns \ntrue\n on any float values.\n\n\nstring\n: Returns \nfalse\n when an empty string \n''\n is given.\n\n\nzero\n: Returns \nfalse\n when the single character zero (\n'0'\n) is given.\n\n\nempty_array\n: Returns \nfalse\n when an empty \narray\n is given.\n\n\nnull\n: Returns \nfalse\n when a \nnull\n value is given.\n\n\nphp\n: Returns \nfalse\n on wherever PHP's \nempty()\n would return \ntrue\n.\n\n\nspace\n: Returns \nfalse\n when an string is given which contains only\n  whitespace.\n\n\nobject\n: Returns \ntrue\n. \nfalse\n will be returned when \nobject\n is not\n  allowed but an object is given.\n\n\nobject_string\n: Returns \nfalse\n when an object is given and its\n  \n__toString()\n method returns an empty string.\n\n\nobject_count\n: Returns \nfalse\n when an object is given, it implements\n  \nCountable\n, and its count is 0.\n\n\nall\n: Returns \nfalse\n on all above types.\n\n\n\n\nAll other given values will return \ntrue\n per default.\n\n\nThere are several ways to select which of the above types are validated. You can\ngive one or multiple types and add them, you can provide an array, you can use\nconstants, or you can provide a textual string. See the following examples:\n\n\nuse Zend\\Validator\\NotEmpty;\n\n// Returns false on 0\n$validator = new NotEmpty(NotEmpty::INTEGER);\n\n// Returns false on 0 or '0'\n$validator = new NotEmpty( NotEmpty::INTEGER | NotEmpty::ZERO);\n\n// Returns false on 0 or '0'\n$validator = new NotEmpty([ NotEmpty::INTEGER, NotEmpty::ZERO ]);\n\n// Returns false on 0 or '0'\n$validator = new NotEmpty(['integer', 'zero']);\n\n\n\n\nYou can also provide an instance of \nTraversable\n to set the desired types. To\nset types after instantiation, use the \nsetType()\n method.", 
            "title": "NotEmpty"
        }, 
        {
            "location": "/validators/not-empty/#notempty-validator", 
            "text": "This validator allows you to validate if a given value is not empty. This is\noften useful when working with form elements or other user input, where you can\nuse it to ensure required elements have values associated with them.", 
            "title": "NotEmpty Validator"
        }, 
        {
            "location": "/validators/not-empty/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\NotEmpty :   type : Sets the type of validation which will be processed; for details, see\n  the section on  specifying empty behavior .", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/not-empty/#default-behaviour", 
            "text": "By default, this validator works differently than you would expect when you've\nworked with PHP's  empty()  operator. In particular, this validator will\nevaluate both the integer  0  and string  '0'  as empty.  $valid = new Zend\\Validator\\NotEmpty();\n$value  = '';\n$result = $valid- isValid($value);\n// returns false", 
            "title": "Default behaviour"
        }, 
        {
            "location": "/validators/not-empty/#specifying-empty-behavior", 
            "text": "Some projects have differing opinions of what is considered an \"empty\" value: a\nstring with only whitespace might be considered empty, or  0  may be\nconsidered non-empty (particularly for boolean sequences). To accommodate\ndiffering needs,  Zend\\Validator\\NotEmpty  allows you to configure which types\nshould be validated as empty and which not.  The following types can be handled:   boolean : Returns  false  when the boolean value is  false .  integer : Returns  false  when an integer  0  value is given. By default,\n  this validation is not activate and returns  true  for any integer values.  float : Returns  false  when a float  0.0  value is given. By default, this\n  validation is not activate and returns  true  on any float values.  string : Returns  false  when an empty string  ''  is given.  zero : Returns  false  when the single character zero ( '0' ) is given.  empty_array : Returns  false  when an empty  array  is given.  null : Returns  false  when a  null  value is given.  php : Returns  false  on wherever PHP's  empty()  would return  true .  space : Returns  false  when an string is given which contains only\n  whitespace.  object : Returns  true .  false  will be returned when  object  is not\n  allowed but an object is given.  object_string : Returns  false  when an object is given and its\n   __toString()  method returns an empty string.  object_count : Returns  false  when an object is given, it implements\n   Countable , and its count is 0.  all : Returns  false  on all above types.   All other given values will return  true  per default.  There are several ways to select which of the above types are validated. You can\ngive one or multiple types and add them, you can provide an array, you can use\nconstants, or you can provide a textual string. See the following examples:  use Zend\\Validator\\NotEmpty;\n\n// Returns false on 0\n$validator = new NotEmpty(NotEmpty::INTEGER);\n\n// Returns false on 0 or '0'\n$validator = new NotEmpty( NotEmpty::INTEGER | NotEmpty::ZERO);\n\n// Returns false on 0 or '0'\n$validator = new NotEmpty([ NotEmpty::INTEGER, NotEmpty::ZERO ]);\n\n// Returns false on 0 or '0'\n$validator = new NotEmpty(['integer', 'zero']);  You can also provide an instance of  Traversable  to set the desired types. To\nset types after instantiation, use the  setType()  method.", 
            "title": "Specifying empty behavior"
        }, 
        {
            "location": "/validators/regex/", 
            "text": "Regex Validator\n\n\nThis validator allows you to validate if a given string conforms a defined\nregular expression.\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\Regex\n:\n\n\n\n\npattern\n: Sets the regular expression pattern for this validator.\n\n\n\n\nUsage\n\n\nValidation with regular expressions allows complex validations\nwithout writing a custom validator.\n\n\n$validator = new Zend\\Validator\\Regex(['pattern' =\n '/^Test/']);\n\n$validator-\nisValid(\nTest\n); // returns true\n$validator-\nisValid(\nTesting\n); // returns true\n$validator-\nisValid(\nPest\n); // returns false\n\n\n\n\nThe pattern uses the same syntax as \npreg_match()\n. For details about regular\nexpressions take a look into \nPHP's manual about PCRE pattern\nsyntax\n.\n\n\nPattern handling\n\n\nIt is also possible to set a different pattern afterwards by using\n\nsetPattern()\n and to get the actual set pattern with \ngetPattern()\n.\n\n\n$validator = new Zend\\Validator\\Regex(['pattern' =\n '/^Test/']);\n$validator-\nsetPattern('ing$/');\n\n$validator-\nisValid(\nTest\n); // returns false\n$validator-\nisValid(\nTesting\n); // returns true\n$validator-\nisValid(\nPest\n); // returns false", 
            "title": "Regex"
        }, 
        {
            "location": "/validators/regex/#regex-validator", 
            "text": "This validator allows you to validate if a given string conforms a defined\nregular expression.", 
            "title": "Regex Validator"
        }, 
        {
            "location": "/validators/regex/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\Regex :   pattern : Sets the regular expression pattern for this validator.", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/regex/#usage", 
            "text": "Validation with regular expressions allows complex validations\nwithout writing a custom validator.  $validator = new Zend\\Validator\\Regex(['pattern' =  '/^Test/']);\n\n$validator- isValid( Test ); // returns true\n$validator- isValid( Testing ); // returns true\n$validator- isValid( Pest ); // returns false  The pattern uses the same syntax as  preg_match() . For details about regular\nexpressions take a look into  PHP's manual about PCRE pattern\nsyntax .", 
            "title": "Usage"
        }, 
        {
            "location": "/validators/regex/#pattern-handling", 
            "text": "It is also possible to set a different pattern afterwards by using setPattern()  and to get the actual set pattern with  getPattern() .  $validator = new Zend\\Validator\\Regex(['pattern' =  '/^Test/']);\n$validator- setPattern('ing$/');\n\n$validator- isValid( Test ); // returns false\n$validator- isValid( Testing ); // returns true\n$validator- isValid( Pest ); // returns false", 
            "title": "Pattern handling"
        }, 
        {
            "location": "/validators/sitemap/", 
            "text": "Sitemap Validators\n\n\nThe following validators conform to the\n\nSitemap XML protocol\n.\n\n\nSupported options\n\n\nThere are no additional supported options for any of the \nSitemap\n validators.\n\n\nChangefreq\n\n\nZend\\Validator\\Sitemap\\Changefreq\n validates whether a string is valid for\nusing as a 'changefreq' element in a Sitemap XML document. Valid values are:\n'always', 'hourly', 'daily', 'weekly', 'monthly', 'yearly', or 'never'.\n\n\nReturns \ntrue\n if and only if the value is a string and is equal to one of the\nfrequencies specified above.\n\n\nSitemap\\Lastmod\n\n\nZend\\Validator\\Sitemap\\Lastmod\n validates whether a string is valid for using\nas a 'lastmod' element in a Sitemap XML document. The lastmod element should\ncontain a W3C date string, optionally discarding information about time.\n\n\nReturns \ntrue\n if and only if the given value is a string and is valid according\nto the protocol.\n\n\n$validator = new Zend\\Validator\\Sitemap\\Lastmod();\n\n$validator-\nisValid('1999-11-11T22:23:52-02:00'); // true\n$validator-\nisValid('2008-05-12T00:42:52+02:00'); // true\n$validator-\nisValid('1999-11-11'); // true\n$validator-\nisValid('2008-05-12'); // true\n\n$validator-\nisValid('1999-11-11t22:23:52-02:00'); // false\n$validator-\nisValid('2008-05-12T00:42:60+02:00'); // false\n$validator-\nisValid('1999-13-11'); // false\n$validator-\nisValid('2008-05-32'); // false\n$validator-\nisValid('yesterday'); // false\n\n\n\n\nLoc\n\n\nZend\\Validator\\Sitemap\\Loc\n validates whether a string is valid for using as a\n'loc' element in a Sitemap XML document. This uses\n\nZend\\Uri\\Uri::isValid()\n\ninternally.\n\n\nPriority\n\n\nZend\\Validator\\Sitemap\\Priority\n validates whether a value is valid for using\nas a 'priority' element in a Sitemap XML document. The value should be a decimal\nbetween 0.0 and 1.0. This validator accepts both numeric values and string\nvalues.\n\n\n$validator = new Zend\\Validator\\Sitemap\\Priority();\n\n$validator-\nisValid('0.1'); // true\n$validator-\nisValid('0.789'); // true\n$validator-\nisValid(0.8); // true\n$validator-\nisValid(1.0); // true\n\n$validator-\nisValid('1.1'); // false\n$validator-\nisValid('-0.4'); // false\n$validator-\nisValid(1.00001); // false\n$validator-\nisValid(0xFF); // false\n$validator-\nisValid('foo'); // false", 
            "title": "Sitemap"
        }, 
        {
            "location": "/validators/sitemap/#sitemap-validators", 
            "text": "The following validators conform to the Sitemap XML protocol .", 
            "title": "Sitemap Validators"
        }, 
        {
            "location": "/validators/sitemap/#supported-options", 
            "text": "There are no additional supported options for any of the  Sitemap  validators.", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/sitemap/#changefreq", 
            "text": "Zend\\Validator\\Sitemap\\Changefreq  validates whether a string is valid for\nusing as a 'changefreq' element in a Sitemap XML document. Valid values are:\n'always', 'hourly', 'daily', 'weekly', 'monthly', 'yearly', or 'never'.  Returns  true  if and only if the value is a string and is equal to one of the\nfrequencies specified above.", 
            "title": "Changefreq"
        }, 
        {
            "location": "/validators/sitemap/#sitemap92lastmod", 
            "text": "Zend\\Validator\\Sitemap\\Lastmod  validates whether a string is valid for using\nas a 'lastmod' element in a Sitemap XML document. The lastmod element should\ncontain a W3C date string, optionally discarding information about time.  Returns  true  if and only if the given value is a string and is valid according\nto the protocol.  $validator = new Zend\\Validator\\Sitemap\\Lastmod();\n\n$validator- isValid('1999-11-11T22:23:52-02:00'); // true\n$validator- isValid('2008-05-12T00:42:52+02:00'); // true\n$validator- isValid('1999-11-11'); // true\n$validator- isValid('2008-05-12'); // true\n\n$validator- isValid('1999-11-11t22:23:52-02:00'); // false\n$validator- isValid('2008-05-12T00:42:60+02:00'); // false\n$validator- isValid('1999-13-11'); // false\n$validator- isValid('2008-05-32'); // false\n$validator- isValid('yesterday'); // false", 
            "title": "Sitemap\\Lastmod"
        }, 
        {
            "location": "/validators/sitemap/#loc", 
            "text": "Zend\\Validator\\Sitemap\\Loc  validates whether a string is valid for using as a\n'loc' element in a Sitemap XML document. This uses Zend\\Uri\\Uri::isValid() \ninternally.", 
            "title": "Loc"
        }, 
        {
            "location": "/validators/sitemap/#priority", 
            "text": "Zend\\Validator\\Sitemap\\Priority  validates whether a value is valid for using\nas a 'priority' element in a Sitemap XML document. The value should be a decimal\nbetween 0.0 and 1.0. This validator accepts both numeric values and string\nvalues.  $validator = new Zend\\Validator\\Sitemap\\Priority();\n\n$validator- isValid('0.1'); // true\n$validator- isValid('0.789'); // true\n$validator- isValid(0.8); // true\n$validator- isValid(1.0); // true\n\n$validator- isValid('1.1'); // false\n$validator- isValid('-0.4'); // false\n$validator- isValid(1.00001); // false\n$validator- isValid(0xFF); // false\n$validator- isValid('foo'); // false", 
            "title": "Priority"
        }, 
        {
            "location": "/validators/step/", 
            "text": "Step Validator\n\n\nZend\\Validator\\Step\n allows you to validate if a given value is a valid step\nvalue. This validator requires the value to be a numeric value (either string,\nint or float).\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\Step\n:\n\n\n\n\nbaseValue\n: This is the base value from which the step should be computed.\n  This option defaults to \n0\n\n\nstep\n: This is the step value. This option defaults to \n1\n\n\n\n\nBasic usage\n\n\n$validator = new Zend\\Validator\\Step();\n\nif ($validator-\nisValid(1)) {\n    // value is a valid step value\n} else {\n    // false\n}\n\n\n\n\nUsing floating-point values\n\n\nThe \nStep\n validator also supports floating-point base and step values:\n\n\n$validator = new Zend\\Validator\\Step([\n    'baseValue' =\n 1.1,\n    'step'      =\n 2.2,\n]);\n\necho $validator-\nisValid(1.1); // prints true\necho $validator-\nisValid(3.3); // prints true\necho $validator-\nisValid(3.35); // prints false\necho $validator-\nisValid(2.2); // prints false", 
            "title": "Step"
        }, 
        {
            "location": "/validators/step/#step-validator", 
            "text": "Zend\\Validator\\Step  allows you to validate if a given value is a valid step\nvalue. This validator requires the value to be a numeric value (either string,\nint or float).", 
            "title": "Step Validator"
        }, 
        {
            "location": "/validators/step/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\Step :   baseValue : This is the base value from which the step should be computed.\n  This option defaults to  0  step : This is the step value. This option defaults to  1", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/step/#basic-usage", 
            "text": "$validator = new Zend\\Validator\\Step();\n\nif ($validator- isValid(1)) {\n    // value is a valid step value\n} else {\n    // false\n}", 
            "title": "Basic usage"
        }, 
        {
            "location": "/validators/step/#using-floating-point-values", 
            "text": "The  Step  validator also supports floating-point base and step values:  $validator = new Zend\\Validator\\Step([\n    'baseValue' =  1.1,\n    'step'      =  2.2,\n]);\n\necho $validator- isValid(1.1); // prints true\necho $validator- isValid(3.3); // prints true\necho $validator- isValid(3.35); // prints false\necho $validator- isValid(2.2); // prints false", 
            "title": "Using floating-point values"
        }, 
        {
            "location": "/validators/string-length/", 
            "text": "StringLength Validator\n\n\nThis validator allows you to validate if a given string is between a defined\nlength.\n\n\n\n\nSupports only string validation\n\n\nZend\\Validator\\StringLength\n supports only the validation of strings.\nIntegers, floats, dates or objects can not be validated with this validator.\n\n\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\StringLength\n:\n\n\n\n\nencoding\n: Sets the \nICONV\n encoding to use with the string.\n\n\nmin\n: Sets the minimum allowed length for a string.\n\n\nmax\n: Sets the maximum allowed length for a string.\n\n\nlength\n: Holds the actual length of the string.\n\n\n\n\nDefault behaviour\n\n\nBy default, this validator checks if a value is between \nmin\n and \nmax\n using a\ndefault \nmin\n value of \n0\n and default \nmax\n value of \nNULL\n (meaning unlimited).\n\n\nAs such, without any options, the validator only checks that the input is a\nstring.\n\n\nLimiting the maximum string length\n\n\nTo limit the maximum allowed length of a string you need to set the \nmax\n\nproperty. It accepts an integer value as input.\n\n\n$validator = new Zend\\Validator\\StringLength(['max' =\n 6]);\n\n$validator-\nisValid(\nTest\n); // returns true\n$validator-\nisValid(\nTesting\n); // returns false\n\n\n\n\nYou can set the maximum allowed length after instantiation by using the\n\nsetMax()\n method; \ngetMax()\n retrieves the value.\n\n\n$validator = new Zend\\Validator\\StringLength();\n$validator-\nsetMax(6);\n\n$validator-\nisValid(\nTest\n); // returns true\n$validator-\nisValid(\nTesting\n); // returns false\n\n\n\n\nLimiting the minimum string length\n\n\nTo limit the minimal required string length, set the \nmin\n\nproperty using an integer value:\n\n\n$validator = new Zend\\Validator\\StringLength(['min' =\n 5]);\n\n$validator-\nisValid(\nTest\n); // returns false\n$validator-\nisValid(\nTesting\n); // returns true\n\n\n\n\nYou can set the value after instantiation using the \nsetMin()\n\nmethod; \ngetMin()\n retrieves the value.\n\n\n$validator = new Zend\\Validator\\StringLength();\n$validator-\nsetMin(5);\n\n$validator-\nisValid(\nTest\n); // returns false\n$validator-\nisValid(\nTesting\n); // returns true\n\n\n\n\nLimiting both minimum and maximum string length\n\n\nSometimes you will need to set both a minimum and a maximum string length;\nas an example, in a username input, you may want to limit the name to a maximum\nof 30 characters, but require at least three charcters:\n\n\n$validator = new Zend\\Validator\\StringLength(['min' =\n 3, 'max' =\n 30]);\n\n$validator-\nisValid(\n.\n); // returns false\n$validator-\nisValid(\nTest\n); // returns true\n$validator-\nisValid(\nTesting\n); // returns true\n\n\n\n\n\n\nSetting a maximum lower  than the minimum\n\n\nWhen you try to set a lower maximum value than the specified minimum value, or\na higher minimum value as the actual maximum value, the validator will raise\nan exception.\n\n\n\n\nEncoding of values\n\n\nStrings are always using a encoding. Even when you don't set the encoding\nexplicitly, PHP uses one. When your application is using a different encoding\nthan PHP itself, you should set an encoding manually.\n\n\nYou can set an encoding at instantiation with the \nencoding\n option, or by using\nthe \nsetEncoding()\n method. We assume that your installation uses ISO and your\napplication it set to ISO. In this case you will see the below behaviour.\n\n\n$validator = new Zend\\Validator\\StringLength(['min' =\n 6]);\n$validator-\nisValid(\n\u00c4rger\n); // returns false\n\n$validator-\nsetEncoding(\nUTF-8\n);\n$validator-\nisValid(\n\u00c4rger\n); // returns true\n\n$validator2 = new Zend\\Validator\\StringLength([\n    'min' =\n 6,\n    'encoding' =\n 'UTF-8',\n]);\n$validator2-\nisValid(\n\u00c4rger\n); // returns true\n\n\n\n\nWhen your installation and your application are using different encodings, then\nyou should always set an encoding manually.\n\n\nValidation Messages\n\n\nUsing the setMessage() method you can set another message to be returned in case of the specified failure.\n\n\n$validator = new Zend\\Validator\\StringLength(['min' =\n 3, 'max' =\n 30]);\n$validator-\nsetMessage('Youre string is too long. You typed '%length%' chars.', Zend\\Validator\\StringLength::TOO_LONG);", 
            "title": "StringLength"
        }, 
        {
            "location": "/validators/string-length/#stringlength-validator", 
            "text": "This validator allows you to validate if a given string is between a defined\nlength.   Supports only string validation  Zend\\Validator\\StringLength  supports only the validation of strings.\nIntegers, floats, dates or objects can not be validated with this validator.", 
            "title": "StringLength Validator"
        }, 
        {
            "location": "/validators/string-length/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\StringLength :   encoding : Sets the  ICONV  encoding to use with the string.  min : Sets the minimum allowed length for a string.  max : Sets the maximum allowed length for a string.  length : Holds the actual length of the string.", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/string-length/#default-behaviour", 
            "text": "By default, this validator checks if a value is between  min  and  max  using a\ndefault  min  value of  0  and default  max  value of  NULL  (meaning unlimited).  As such, without any options, the validator only checks that the input is a\nstring.", 
            "title": "Default behaviour"
        }, 
        {
            "location": "/validators/string-length/#limiting-the-maximum-string-length", 
            "text": "To limit the maximum allowed length of a string you need to set the  max \nproperty. It accepts an integer value as input.  $validator = new Zend\\Validator\\StringLength(['max' =  6]);\n\n$validator- isValid( Test ); // returns true\n$validator- isValid( Testing ); // returns false  You can set the maximum allowed length after instantiation by using the setMax()  method;  getMax()  retrieves the value.  $validator = new Zend\\Validator\\StringLength();\n$validator- setMax(6);\n\n$validator- isValid( Test ); // returns true\n$validator- isValid( Testing ); // returns false", 
            "title": "Limiting the maximum string length"
        }, 
        {
            "location": "/validators/string-length/#limiting-the-minimum-string-length", 
            "text": "To limit the minimal required string length, set the  min \nproperty using an integer value:  $validator = new Zend\\Validator\\StringLength(['min' =  5]);\n\n$validator- isValid( Test ); // returns false\n$validator- isValid( Testing ); // returns true  You can set the value after instantiation using the  setMin() \nmethod;  getMin()  retrieves the value.  $validator = new Zend\\Validator\\StringLength();\n$validator- setMin(5);\n\n$validator- isValid( Test ); // returns false\n$validator- isValid( Testing ); // returns true", 
            "title": "Limiting the minimum string length"
        }, 
        {
            "location": "/validators/string-length/#limiting-both-minimum-and-maximum-string-length", 
            "text": "Sometimes you will need to set both a minimum and a maximum string length;\nas an example, in a username input, you may want to limit the name to a maximum\nof 30 characters, but require at least three charcters:  $validator = new Zend\\Validator\\StringLength(['min' =  3, 'max' =  30]);\n\n$validator- isValid( . ); // returns false\n$validator- isValid( Test ); // returns true\n$validator- isValid( Testing ); // returns true", 
            "title": "Limiting both minimum and maximum string length"
        }, 
        {
            "location": "/validators/string-length/#setting-a-maximum-lower-than-the-minimum", 
            "text": "When you try to set a lower maximum value than the specified minimum value, or\na higher minimum value as the actual maximum value, the validator will raise\nan exception.", 
            "title": "Setting a maximum lower  than the minimum"
        }, 
        {
            "location": "/validators/string-length/#encoding-of-values", 
            "text": "Strings are always using a encoding. Even when you don't set the encoding\nexplicitly, PHP uses one. When your application is using a different encoding\nthan PHP itself, you should set an encoding manually.  You can set an encoding at instantiation with the  encoding  option, or by using\nthe  setEncoding()  method. We assume that your installation uses ISO and your\napplication it set to ISO. In this case you will see the below behaviour.  $validator = new Zend\\Validator\\StringLength(['min' =  6]);\n$validator- isValid( \u00c4rger ); // returns false\n\n$validator- setEncoding( UTF-8 );\n$validator- isValid( \u00c4rger ); // returns true\n\n$validator2 = new Zend\\Validator\\StringLength([\n    'min' =  6,\n    'encoding' =  'UTF-8',\n]);\n$validator2- isValid( \u00c4rger ); // returns true  When your installation and your application are using different encodings, then\nyou should always set an encoding manually.", 
            "title": "Encoding of values"
        }, 
        {
            "location": "/validators/string-length/#validation-messages", 
            "text": "Using the setMessage() method you can set another message to be returned in case of the specified failure.  $validator = new Zend\\Validator\\StringLength(['min' =  3, 'max' =  30]);\n$validator- setMessage('Youre string is too long. You typed '%length%' chars.', Zend\\Validator\\StringLength::TOO_LONG);", 
            "title": "Validation Messages"
        }, 
        {
            "location": "/validators/timezone/", 
            "text": "Timezone Validator\n\n\nZend\\Validator\\Timezone\n allows validating if an input string represents a\ntimezone.\n\n\nSupported validation types\n\n\nThe \nZend\\Validator\\Timezone\n validator is capable of validating the\nabbreviation (e.g. \newt\n) as well as the location string (e.g.\n\nAmerica/Los_Angeles\n). These options are stored in the validator as\n\nLOCATION\n, \nABBREVIATION\n, and \nALL\n class constants.\n\n\nBasic Usage\n\n\nThe default validation type will check against abbreviations as well as the\nlocation string.\n\n\n$validator = new Zend\\Validator\\Timezone();\n\n$validator-\nisValid('America/Los_Angeles'); // returns true\n$validator-\nisValid('ewt'); // returns true\n$validator-\nisValid('Foobar');  // returns false\n\n\n\n\nTo validate against only the location string you can set the type:\n\n\nuse Zend\\Validator\\Timezone;\n\n$validator = new Timezone();\n$validator-\nsetType(Timezone::LOCATION);\n\n$validator-\nisValid('America/Los_Angeles'); // returns true\n$validator-\nisValid('ewt'); // returns false\n$validator-\nisValid('Foobar');  // returns false", 
            "title": "Timezone"
        }, 
        {
            "location": "/validators/timezone/#timezone-validator", 
            "text": "Zend\\Validator\\Timezone  allows validating if an input string represents a\ntimezone.", 
            "title": "Timezone Validator"
        }, 
        {
            "location": "/validators/timezone/#supported-validation-types", 
            "text": "The  Zend\\Validator\\Timezone  validator is capable of validating the\nabbreviation (e.g.  ewt ) as well as the location string (e.g. America/Los_Angeles ). These options are stored in the validator as LOCATION ,  ABBREVIATION , and  ALL  class constants.", 
            "title": "Supported validation types"
        }, 
        {
            "location": "/validators/timezone/#basic-usage", 
            "text": "The default validation type will check against abbreviations as well as the\nlocation string.  $validator = new Zend\\Validator\\Timezone();\n\n$validator- isValid('America/Los_Angeles'); // returns true\n$validator- isValid('ewt'); // returns true\n$validator- isValid('Foobar');  // returns false  To validate against only the location string you can set the type:  use Zend\\Validator\\Timezone;\n\n$validator = new Timezone();\n$validator- setType(Timezone::LOCATION);\n\n$validator- isValid('America/Los_Angeles'); // returns true\n$validator- isValid('ewt'); // returns false\n$validator- isValid('Foobar');  // returns false", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/validators/uri/", 
            "text": "Uri Validator\n\n\nZend\\Validator\\Uri\n allows you to validate a URI using the \nZend\\Uri\\Uri\n\nhandler to parse the URI. The validator allows for both validation of absolute\nand/or relative URIs. There is the possibility to exchange the handler for\nanother one in case the parsing of the uri should be done differently.\n\n\nSupported options\n\n\nThe following options are supported for \nZend\\Validator\\Uri\n:\n\n\n\n\nuriHandler\n: Defines the handler to be used to parse the uri. This options\n  defaults to a new instance of \nZend\\Uri\\Uri\n.\n\n\nallowRelative\n: Defines if relative paths are allowed. This option defaults\n  to \ntrue\n.\n\n\nallowAbsolute\n: Defines if absolute paths are allowed. This option defaults\n  to \ntrue\n.\n\n\n\n\nBasic usage\n\n\n$validator = new Zend\\Validator\\Uri();\n$uri = 'http://framework.zend.com/manual';\n\nif ($validator-\nisValid($uri)) {\n    // $uri was valid\n} else {\n    // false. You can use $validator-\ngetMessages() to retrieve error messages\n}", 
            "title": "Uri"
        }, 
        {
            "location": "/validators/uri/#uri-validator", 
            "text": "Zend\\Validator\\Uri  allows you to validate a URI using the  Zend\\Uri\\Uri \nhandler to parse the URI. The validator allows for both validation of absolute\nand/or relative URIs. There is the possibility to exchange the handler for\nanother one in case the parsing of the uri should be done differently.", 
            "title": "Uri Validator"
        }, 
        {
            "location": "/validators/uri/#supported-options", 
            "text": "The following options are supported for  Zend\\Validator\\Uri :   uriHandler : Defines the handler to be used to parse the uri. This options\n  defaults to a new instance of  Zend\\Uri\\Uri .  allowRelative : Defines if relative paths are allowed. This option defaults\n  to  true .  allowAbsolute : Defines if absolute paths are allowed. This option defaults\n  to  true .", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/uri/#basic-usage", 
            "text": "$validator = new Zend\\Validator\\Uri();\n$uri = 'http://framework.zend.com/manual';\n\nif ($validator- isValid($uri)) {\n    // $uri was valid\n} else {\n    // false. You can use $validator- getMessages() to retrieve error messages\n}", 
            "title": "Basic usage"
        }, 
        {
            "location": "/validators/uuid/", 
            "text": "UUID Validator\n\n\nZend\\Validator\\Uuid\n allows validating \nUniversally Unique IDentifiers\n\n(UUIDs). UUIDs are 128-bit values that are guaranteed to be \"practically unique\"\nin order to help prevent identifier conflicts. Five separate UUID versions\nexist:\n\n\n\n\nVersion 1, which uses a combination of date-time and hardware MAC addresses to\n  generate the hash.\n\n\nVersion 2, which uses a combination of date-time and system user/group identifiers.\n\n\nVersion 3, which uses an MD5sum of a URI or distinguished name to generate the\n  hash.\n\n\nVersion 4, which uses a CSPRNG to generate the hash.\n\n\nVersion 5, which uses the same idea as Version 3, but using SHA-1 for hashing.\n\n\n\n\nThe \nUuid\n validator is capable of validating whether a string is a valid UUID\nof any version. It does not validate that the UUID exists in your system,\nhowever, only that it is well-formed.\n\n\n\n\nIntroduced in 2.8.0\n\n\nZend\\Validator\\Uuid\n was introduced with version 2.8.0.\n\n\n\n\nSupported options\n\n\nThe \nUuid\n validator has no additional options.\n\n\nBasic usage\n\n\n$validator = new Zend\\Validator\\Uuid();\n\nif ($validator-\nisValid($uuid)) {\n    // UUID was valid\n} else {\n    // Invalid/mal-formed UUID; use $validator-\ngetMessages() for more detail\n}", 
            "title": "Uuid"
        }, 
        {
            "location": "/validators/uuid/#uuid-validator", 
            "text": "Zend\\Validator\\Uuid  allows validating  Universally Unique IDentifiers \n(UUIDs). UUIDs are 128-bit values that are guaranteed to be \"practically unique\"\nin order to help prevent identifier conflicts. Five separate UUID versions\nexist:   Version 1, which uses a combination of date-time and hardware MAC addresses to\n  generate the hash.  Version 2, which uses a combination of date-time and system user/group identifiers.  Version 3, which uses an MD5sum of a URI or distinguished name to generate the\n  hash.  Version 4, which uses a CSPRNG to generate the hash.  Version 5, which uses the same idea as Version 3, but using SHA-1 for hashing.   The  Uuid  validator is capable of validating whether a string is a valid UUID\nof any version. It does not validate that the UUID exists in your system,\nhowever, only that it is well-formed.", 
            "title": "UUID Validator"
        }, 
        {
            "location": "/validators/uuid/#introduced-in-280", 
            "text": "Zend\\Validator\\Uuid  was introduced with version 2.8.0.", 
            "title": "Introduced in 2.8.0"
        }, 
        {
            "location": "/validators/uuid/#supported-options", 
            "text": "The  Uuid  validator has no additional options.", 
            "title": "Supported options"
        }, 
        {
            "location": "/validators/uuid/#basic-usage", 
            "text": "$validator = new Zend\\Validator\\Uuid();\n\nif ($validator- isValid($uuid)) {\n    // UUID was valid\n} else {\n    // Invalid/mal-formed UUID; use $validator- getMessages() for more detail\n}", 
            "title": "Basic usage"
        }, 
        {
            "location": "/validators/file/intro/", 
            "text": "File Validation Classes\n\n\nZend Framework comes with a set of classes for validating both files and\nuploaded files, such as file size validation and CRC checking.\n\n\n\n\nCount\n\n\ncrc32\n\n\nExcludeExtension\n\n\nExcludeMimeType\n\n\nExists\n\n\nExtension\n\n\nFilesSize\n\n\nHash\n\n\nImageSize\n\n\nIsCompressed\n\n\nIsImage\n\n\nMd5\n\n\nMimeType\n\n\nNotExists\n\n\nSha1\n\n\nSize\n\n\nUpload\n\n\nUploadFile\n\n\nWordCount\n\n\n\n\n\n\nValidation argument\n\n\nAll of the File validators' \nisValid()\n methods support both a file path\n\nstring\n \nor\n a \n$_FILES\n array as the supplied argument. When a \n$_FILES\n\narray is passed in, the \ntmp_name\n is used for the file path.", 
            "title": "Intro"
        }, 
        {
            "location": "/validators/file/intro/#file-validation-classes", 
            "text": "Zend Framework comes with a set of classes for validating both files and\nuploaded files, such as file size validation and CRC checking.   Count  crc32  ExcludeExtension  ExcludeMimeType  Exists  Extension  FilesSize  Hash  ImageSize  IsCompressed  IsImage  Md5  MimeType  NotExists  Sha1  Size  Upload  UploadFile  WordCount", 
            "title": "File Validation Classes"
        }, 
        {
            "location": "/validators/file/intro/#validation-argument", 
            "text": "All of the File validators'  isValid()  methods support both a file path string   or  a  $_FILES  array as the supplied argument. When a  $_FILES \narray is passed in, the  tmp_name  is used for the file path.", 
            "title": "Validation argument"
        }, 
        {
            "location": "/validators/file/count/", 
            "text": "Count\n\n\nZend\\Validator\\File\\Count\n allows you to validate that the number of files\nuploaded matches criteria, including a minimum number of files and/or a maximum\nnumber of files.\n\n\nSupported Options\n\n\nThe following options are supported:\n\n\n\n\nmin\n: The minimum number of uploaded files acceptable; \nnull\n is equivalent\n  to \n0\n, indicating no minimum.\n\n\nmax\n: The maximum number of uploaded files acceptable; \nnull\n is equivalent\n  to no maximum.\n\n\n\n\nBasic Usage\n\n\n$validator = new Zend\\Validator\\File\\Count([\n    'min' =\n 1,\n    'max' =\n 5,\n]);\n\n// Setting to the $_FILES superglobal; could also use the zend-http\n// request's `getFiles()` or PSR-7 ServerRequest's `getUploadedFiles()`.\n$files = $_FILES;\n\nif ($validator-\nisValid($files)) {\n    // Received between 1 and 5 files!\n}", 
            "title": "Count"
        }, 
        {
            "location": "/validators/file/count/#count", 
            "text": "Zend\\Validator\\File\\Count  allows you to validate that the number of files\nuploaded matches criteria, including a minimum number of files and/or a maximum\nnumber of files.", 
            "title": "Count"
        }, 
        {
            "location": "/validators/file/count/#supported-options", 
            "text": "The following options are supported:   min : The minimum number of uploaded files acceptable;  null  is equivalent\n  to  0 , indicating no minimum.  max : The maximum number of uploaded files acceptable;  null  is equivalent\n  to no maximum.", 
            "title": "Supported Options"
        }, 
        {
            "location": "/validators/file/count/#basic-usage", 
            "text": "$validator = new Zend\\Validator\\File\\Count([\n    'min' =  1,\n    'max' =  5,\n]);\n\n// Setting to the $_FILES superglobal; could also use the zend-http\n// request's `getFiles()` or PSR-7 ServerRequest's `getUploadedFiles()`.\n$files = $_FILES;\n\nif ($validator- isValid($files)) {\n    // Received between 1 and 5 files!\n}", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/validators/file/crc32/", 
            "text": "Crc32\n\n\nZend\\Validator\\File\\Crc32\n allows you to validate if a given file's hashed\ncontents matches the supplied crc32 hash(es). It is subclassed from the \nHash\nvalidator\n to provide a validator that only supports the \ncrc32\n\nalgorithm.\n\n\n\n\nRequires the hash extension\n\n\nThis validator requires the PHP \nHash extension\n with the\n\ncrc32\n algorithm.\n\n\n\n\nSupported Options\n\n\nThe following options are supported:\n\n\n\n\nhash\n: Single string hash to test the file against, or array of filename/hash\n  pairs.\n\n\n\n\nUsage Examples\n\n\n// Does file have the given hash?\n$validator = new \\Zend\\Validator\\File\\Crc32('3b3652f');\n\n// Or, check file against multiple hashes\n$validator = new \\Zend\\Validator\\File\\Crc32(['3b3652f', 'e612b69']);\n\n// Perform validation with file path\nif ($validator-\nisValid('./myfile.txt')) {\n    // file is valid\n}\n\n\n\n\nPublic Methods\n\n\ngetCrc32\n\n\ngetCrc32() : array\n\n\n\n\nReturns an array of all currently registered hashes to test against.\n\n\naddCrc32\n\n\naddCrc32(string|array $options) : void\n\n\n\n\nAdd a single hash to test against, or a set of filename/hash pairs to test\nagainst.\n\n\nsetCrc32\n\n\nsetCrc32(string|array $options): void\n\n\n\n\nOverwrite the current list of registered hashes with the one(s) provided.", 
            "title": "Crc32"
        }, 
        {
            "location": "/validators/file/crc32/#crc32", 
            "text": "Zend\\Validator\\File\\Crc32  allows you to validate if a given file's hashed\ncontents matches the supplied crc32 hash(es). It is subclassed from the  Hash\nvalidator  to provide a validator that only supports the  crc32 \nalgorithm.", 
            "title": "Crc32"
        }, 
        {
            "location": "/validators/file/crc32/#requires-the-hash-extension", 
            "text": "This validator requires the PHP  Hash extension  with the crc32  algorithm.", 
            "title": "Requires the hash extension"
        }, 
        {
            "location": "/validators/file/crc32/#supported-options", 
            "text": "The following options are supported:   hash : Single string hash to test the file against, or array of filename/hash\n  pairs.", 
            "title": "Supported Options"
        }, 
        {
            "location": "/validators/file/crc32/#usage-examples", 
            "text": "// Does file have the given hash?\n$validator = new \\Zend\\Validator\\File\\Crc32('3b3652f');\n\n// Or, check file against multiple hashes\n$validator = new \\Zend\\Validator\\File\\Crc32(['3b3652f', 'e612b69']);\n\n// Perform validation with file path\nif ($validator- isValid('./myfile.txt')) {\n    // file is valid\n}", 
            "title": "Usage Examples"
        }, 
        {
            "location": "/validators/file/crc32/#public-methods", 
            "text": "", 
            "title": "Public Methods"
        }, 
        {
            "location": "/validators/file/crc32/#getcrc32", 
            "text": "getCrc32() : array  Returns an array of all currently registered hashes to test against.", 
            "title": "getCrc32"
        }, 
        {
            "location": "/validators/file/crc32/#addcrc32", 
            "text": "addCrc32(string|array $options) : void  Add a single hash to test against, or a set of filename/hash pairs to test\nagainst.", 
            "title": "addCrc32"
        }, 
        {
            "location": "/validators/file/crc32/#setcrc32", 
            "text": "setCrc32(string|array $options): void  Overwrite the current list of registered hashes with the one(s) provided.", 
            "title": "setCrc32"
        }, 
        {
            "location": "/validators/file/exclude-extension/", 
            "text": "ExcludeExtension\n\n\nZend\\Validator\\File\\ExcludeExtension\n checks the extension of files. It will\nassert \nfalse\n when a given file matches any of the defined extensions.\n\n\nThis validator is inversely related to the \nExtension validator\n;\nplease refer to that validator for full options and usage examples.", 
            "title": "ExcludeExtension"
        }, 
        {
            "location": "/validators/file/exclude-extension/#excludeextension", 
            "text": "Zend\\Validator\\File\\ExcludeExtension  checks the extension of files. It will\nassert  false  when a given file matches any of the defined extensions.  This validator is inversely related to the  Extension validator ;\nplease refer to that validator for full options and usage examples.", 
            "title": "ExcludeExtension"
        }, 
        {
            "location": "/validators/file/exclude-mime-type/", 
            "text": "ExcludeMimeType\n\n\nZend\\Validator\\File\\ExcludeMimeType\n checks the MIME type of files. It will\nassert \nfalse\n when a given file matches any of the defined MIME types.\n\n\nThis validator is inversely related to the \nMimeType validator\n;\nplease refer to that validator's documentation for full options and usage\nexamples.", 
            "title": "ExcludeMimeType"
        }, 
        {
            "location": "/validators/file/exclude-mime-type/#excludemimetype", 
            "text": "Zend\\Validator\\File\\ExcludeMimeType  checks the MIME type of files. It will\nassert  false  when a given file matches any of the defined MIME types.  This validator is inversely related to the  MimeType validator ;\nplease refer to that validator's documentation for full options and usage\nexamples.", 
            "title": "ExcludeMimeType"
        }, 
        {
            "location": "/validators/file/exists/", 
            "text": "Exists\n\n\nZend\\Validator\\File\\Exists\n checks for the existence of files in specified\ndirectories.\n\n\nThis validator is inversely related to the \nNotExists validator\n.\n\n\nSupported Options\n\n\nThe following set of options are supported:\n\n\n\n\ndirectory\n: Array of directories, or comma-delimited string  of directories.\n\n\n\n\nUsage Examples\n\n\nuse Zend\\Validator\\File\\Exists;\n\n// Only allow files that exist in ~both~ directories\n$validator = new Exists('/tmp,/var/tmp');\n\n// ...or with array notation\n$validator = new Exists(['/tmp', '/var/tmp']);\n\n// Perform validation\nif ($validator-\nisValid('/tmp/myfile.txt')) {\n    // file is valid\n}\n\n\n\n\n\n\nChecks against all directories\n\n\nThis validator checks whether the specified file exists in \nall\n of the\ngiven directories; validation will fail if the file does not exist in one\nor more of them.", 
            "title": "Exists"
        }, 
        {
            "location": "/validators/file/exists/#exists", 
            "text": "Zend\\Validator\\File\\Exists  checks for the existence of files in specified\ndirectories.  This validator is inversely related to the  NotExists validator .", 
            "title": "Exists"
        }, 
        {
            "location": "/validators/file/exists/#supported-options", 
            "text": "The following set of options are supported:   directory : Array of directories, or comma-delimited string  of directories.", 
            "title": "Supported Options"
        }, 
        {
            "location": "/validators/file/exists/#usage-examples", 
            "text": "use Zend\\Validator\\File\\Exists;\n\n// Only allow files that exist in ~both~ directories\n$validator = new Exists('/tmp,/var/tmp');\n\n// ...or with array notation\n$validator = new Exists(['/tmp', '/var/tmp']);\n\n// Perform validation\nif ($validator- isValid('/tmp/myfile.txt')) {\n    // file is valid\n}", 
            "title": "Usage Examples"
        }, 
        {
            "location": "/validators/file/exists/#checks-against-all-directories", 
            "text": "This validator checks whether the specified file exists in  all  of the\ngiven directories; validation will fail if the file does not exist in one\nor more of them.", 
            "title": "Checks against all directories"
        }, 
        {
            "location": "/validators/file/extension/", 
            "text": "Extension\n\n\nZend\\Validator\\File\\Extension\n checks the extension of files. It will assert\n\ntrue\n when a given file matches any of the defined extensions.\n\n\nThis validator is inversely related to the\n\nExcludeExtension validator\n.\n\n\nSupported Options\n\n\nThe following set of options are supported:\n\n\n\n\nextension\n: Array of extensions, or comma-delimited string of extensions,\n  against which to test.\n\n\ncase\n: Boolean indicating whether or not extensions should match case\n  sensitively; defaults to \nfalse\n (case-insensitive).\n\n\n\n\nUsage Examples\n\n\nuse Zend\\Validator\\File\\Extension;\n\n// Allow files with 'php' or 'exe' extensions\n$validator = new Extension('php,exe');\n\n// ...or with array notation\n$validator = new Extension(['php', 'exe']);\n\n// Test with case-sensitivity on\n$validator = new Extension(['php', 'exe'], true);\n\n// Using an options array:\n$validator = new Extension([\n    'extension' =\n ['php', 'exe'],\n    'case' =\n true,\n]);\n\n// Perform validation\nif ($validator-\nisValid('./myfile.php')) {\n    // file is valid\n}\n\n\n\n\nPublic Methods\n\n\naddExtension\n\n\naddExtension(string|array $options) : void\n\n\n\n\nAdd one or more extensions as a comma-separated list, or as an array.", 
            "title": "Extension"
        }, 
        {
            "location": "/validators/file/extension/#extension", 
            "text": "Zend\\Validator\\File\\Extension  checks the extension of files. It will assert true  when a given file matches any of the defined extensions.  This validator is inversely related to the ExcludeExtension validator .", 
            "title": "Extension"
        }, 
        {
            "location": "/validators/file/extension/#supported-options", 
            "text": "The following set of options are supported:   extension : Array of extensions, or comma-delimited string of extensions,\n  against which to test.  case : Boolean indicating whether or not extensions should match case\n  sensitively; defaults to  false  (case-insensitive).", 
            "title": "Supported Options"
        }, 
        {
            "location": "/validators/file/extension/#usage-examples", 
            "text": "use Zend\\Validator\\File\\Extension;\n\n// Allow files with 'php' or 'exe' extensions\n$validator = new Extension('php,exe');\n\n// ...or with array notation\n$validator = new Extension(['php', 'exe']);\n\n// Test with case-sensitivity on\n$validator = new Extension(['php', 'exe'], true);\n\n// Using an options array:\n$validator = new Extension([\n    'extension' =  ['php', 'exe'],\n    'case' =  true,\n]);\n\n// Perform validation\nif ($validator- isValid('./myfile.php')) {\n    // file is valid\n}", 
            "title": "Usage Examples"
        }, 
        {
            "location": "/validators/file/extension/#public-methods", 
            "text": "", 
            "title": "Public Methods"
        }, 
        {
            "location": "/validators/file/extension/#addextension", 
            "text": "addExtension(string|array $options) : void  Add one or more extensions as a comma-separated list, or as an array.", 
            "title": "addExtension"
        }, 
        {
            "location": "/validators/file/files-size/", 
            "text": "FilesSize\n\n\nZend\\Validator\\File\\FilesSize\n allows validating the total size of all file\nuploads in aggregate, allowing specifying a minimum upload size and/or a maximum\nupload size.\n\n\nOnly use this validator if you will be expecting multiple file uploads in a\nsingle payload, and want to ensure the aggregate size falls within a specific\nrange.\n\n\nSupported Options\n\n\nZend\\Validator\\File\\FilesSize\n supports the following options:\n\n\n\n\nmin\n: The minimum aggregate size of all file uploads. May be specified as an\n  integer or using SI units. \nnull\n indicates no minimum size is required.\n\n\nmax\n: The maximum aggregate size of all file uploads. May be specified as an\n  integer or using SI units. \nnull\n indicates no maximum size is required.\n\n\nuseByteString\n: A flag indicating whether sizes should be reported as\n  integers or using SI units when reporting validation errors.\n\n\n\n\nSee the \nSize validator\n for details on supported SI\nunits.\n\n\nBasic Usage\n\n\nuse Zend\\Validator\\File\\FilesSize;\n\n$validator = new FilesSize([\n    'min' =\n '1kB`,  // minimum of 1kB\n    'max' =\n `10MB', // maximum of 10MB\n]);\n\nif ($validator-\nisValid($_FILES)) {\n    // \n 1kB, \n 10MB in aggregate\n}", 
            "title": "FilesSize"
        }, 
        {
            "location": "/validators/file/files-size/#filessize", 
            "text": "Zend\\Validator\\File\\FilesSize  allows validating the total size of all file\nuploads in aggregate, allowing specifying a minimum upload size and/or a maximum\nupload size.  Only use this validator if you will be expecting multiple file uploads in a\nsingle payload, and want to ensure the aggregate size falls within a specific\nrange.", 
            "title": "FilesSize"
        }, 
        {
            "location": "/validators/file/files-size/#supported-options", 
            "text": "Zend\\Validator\\File\\FilesSize  supports the following options:   min : The minimum aggregate size of all file uploads. May be specified as an\n  integer or using SI units.  null  indicates no minimum size is required.  max : The maximum aggregate size of all file uploads. May be specified as an\n  integer or using SI units.  null  indicates no maximum size is required.  useByteString : A flag indicating whether sizes should be reported as\n  integers or using SI units when reporting validation errors.   See the  Size validator  for details on supported SI\nunits.", 
            "title": "Supported Options"
        }, 
        {
            "location": "/validators/file/files-size/#basic-usage", 
            "text": "use Zend\\Validator\\File\\FilesSize;\n\n$validator = new FilesSize([\n    'min' =  '1kB`,  // minimum of 1kB\n    'max' =  `10MB', // maximum of 10MB\n]);\n\nif ($validator- isValid($_FILES)) {\n    //   1kB,   10MB in aggregate\n}", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/validators/file/hash/", 
            "text": "Hash\n\n\nZend\\Validator\\File\\Hash\n allows you to validate if a given file's hashed\ncontents matches the supplied hash(es) and algorithm(s).\n\n\n\n\nRequires the hash extension\n\n\nThis validator requires the PHP \nHash extension\n. A list\nof supported hash algorithms can be found with the\n\nhash_algos() function\n.\n\n\n\n\nSupported Options\n\n\nThe following set of options are supported:\n\n\n\n\nhash\n: String hash or array of hashes against which to test.\n\n\nalgorithm\n: String hashing algorithm to use; defaults to \ncrc32\n\n\n\n\nBasic Usage\n\n\nuse Zend\\Validator\\File\\Hash;\n\n// Does file have the given hash?\n$validator = new Hash('3b3652f', 'crc32');\n\n// Or, check file against multiple hashes\n$validator = new Hash(['3b3652f', 'e612b69'], 'crc32');\n\n// Or use options notation:\n$validator = new Hash([\n    'hash' =\n ['3b3652f', 'e612b69'],\n    'algorithm' =\n 'crc32',\n]);\n\n// Perform validation with file path\nif ($validator-\nisValid('./myfile.txt')) {\n   // file is valid\n}\n\n\n\n\nPublic Methods\n\n\ngetHash\n\n\ngetHash() : array\n\n\n\n\nReturns an array containing the set of hashes against which to validate.\n\n\naddHash\n\n\naddHash(string|array $options) : void\n\n\n\n\nAdd one or more hashes against which to validate.\n\n\nsetHash\n\n\nsetHash(string|array $options) : void\n\n\n\n\nOverwrite the current set of hashes with those provided to the method.", 
            "title": "Hash"
        }, 
        {
            "location": "/validators/file/hash/#hash", 
            "text": "Zend\\Validator\\File\\Hash  allows you to validate if a given file's hashed\ncontents matches the supplied hash(es) and algorithm(s).", 
            "title": "Hash"
        }, 
        {
            "location": "/validators/file/hash/#requires-the-hash-extension", 
            "text": "This validator requires the PHP  Hash extension . A list\nof supported hash algorithms can be found with the hash_algos() function .", 
            "title": "Requires the hash extension"
        }, 
        {
            "location": "/validators/file/hash/#supported-options", 
            "text": "The following set of options are supported:   hash : String hash or array of hashes against which to test.  algorithm : String hashing algorithm to use; defaults to  crc32", 
            "title": "Supported Options"
        }, 
        {
            "location": "/validators/file/hash/#basic-usage", 
            "text": "use Zend\\Validator\\File\\Hash;\n\n// Does file have the given hash?\n$validator = new Hash('3b3652f', 'crc32');\n\n// Or, check file against multiple hashes\n$validator = new Hash(['3b3652f', 'e612b69'], 'crc32');\n\n// Or use options notation:\n$validator = new Hash([\n    'hash' =  ['3b3652f', 'e612b69'],\n    'algorithm' =  'crc32',\n]);\n\n// Perform validation with file path\nif ($validator- isValid('./myfile.txt')) {\n   // file is valid\n}", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/validators/file/hash/#public-methods", 
            "text": "", 
            "title": "Public Methods"
        }, 
        {
            "location": "/validators/file/hash/#gethash", 
            "text": "getHash() : array  Returns an array containing the set of hashes against which to validate.", 
            "title": "getHash"
        }, 
        {
            "location": "/validators/file/hash/#addhash", 
            "text": "addHash(string|array $options) : void  Add one or more hashes against which to validate.", 
            "title": "addHash"
        }, 
        {
            "location": "/validators/file/hash/#sethash", 
            "text": "setHash(string|array $options) : void  Overwrite the current set of hashes with those provided to the method.", 
            "title": "setHash"
        }, 
        {
            "location": "/validators/file/image-size/", 
            "text": "ImageSize\n\n\nZend\\Validator\\File\\ImageSize\n checks the size of image files. Minimum and/or\nmaximum dimensions can be set to validate against.\n\n\nSupported Options\n\n\nThe following set of options are supported:\n\n\n\n\nminWidth\n: Set the minimum image width as an integer; \nnull\n (the default)\n  indicates no minimum.\n\n\nminHeight\n: Set the minimum image height as an integer; \nnull\n (the default)\n  indicates no minimum.\n\n\nmaxWidth\n: Set the maximum image width as an integer; \nnull\n (the default)\n  indicates no maximum.\n\n\nmaxHeight\n: Set the maximum image height as an integer; \nnull\n (the default)\n  indicates no maximum.\n\n\n\n\nBasic Usage\n\n\nuse Zend\\Validator\\File\\ImageSize;\n\n// Is image size between 320x200 (min) and 640x480 (max)?\n$validator = new ImageSize(320, 200, 640, 480);\n\n// ...or with array notation\n$validator = new ImageSize([\n    'minWidth' =\n 320,\n    'minHeight' =\n 200,\n    'maxWidth' =\n 640,\n    'maxHeight' =\n 480,\n]);\n\n// Is image size equal to or larger than 320x200?\n$validator = new ImageSize([\n    'minWidth' =\n 320,\n    'minHeight' =\n 200,\n]);\n\n// Is image size equal to or smaller than 640x480?\n$validator = new ImageSize([\n    'maxWidth' =\n 640,\n    'maxHeight' =\n 480,\n]);\n\n// Perform validation with file path\nif ($validator-\nisValid('./myfile.jpg')) {\n    // file is valid\n}\n\n\n\n\nPublic Methods\n\n\ngetImageMin\n\n\ngetImageMin() : array\n\n\n\n\nReturns the minimum valid dimensions as an array with the keys \nwidth\n and\n\nheight\n.\n\n\ngetImageMax\n\n\ngetImageMax() : array\n\n\n\n\nReturns the maximum valid dimensions as an array with the keys \nwidth\n and\n\nheight\n.", 
            "title": "ImageSize"
        }, 
        {
            "location": "/validators/file/image-size/#imagesize", 
            "text": "Zend\\Validator\\File\\ImageSize  checks the size of image files. Minimum and/or\nmaximum dimensions can be set to validate against.", 
            "title": "ImageSize"
        }, 
        {
            "location": "/validators/file/image-size/#supported-options", 
            "text": "The following set of options are supported:   minWidth : Set the minimum image width as an integer;  null  (the default)\n  indicates no minimum.  minHeight : Set the minimum image height as an integer;  null  (the default)\n  indicates no minimum.  maxWidth : Set the maximum image width as an integer;  null  (the default)\n  indicates no maximum.  maxHeight : Set the maximum image height as an integer;  null  (the default)\n  indicates no maximum.", 
            "title": "Supported Options"
        }, 
        {
            "location": "/validators/file/image-size/#basic-usage", 
            "text": "use Zend\\Validator\\File\\ImageSize;\n\n// Is image size between 320x200 (min) and 640x480 (max)?\n$validator = new ImageSize(320, 200, 640, 480);\n\n// ...or with array notation\n$validator = new ImageSize([\n    'minWidth' =  320,\n    'minHeight' =  200,\n    'maxWidth' =  640,\n    'maxHeight' =  480,\n]);\n\n// Is image size equal to or larger than 320x200?\n$validator = new ImageSize([\n    'minWidth' =  320,\n    'minHeight' =  200,\n]);\n\n// Is image size equal to or smaller than 640x480?\n$validator = new ImageSize([\n    'maxWidth' =  640,\n    'maxHeight' =  480,\n]);\n\n// Perform validation with file path\nif ($validator- isValid('./myfile.jpg')) {\n    // file is valid\n}", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/validators/file/image-size/#public-methods", 
            "text": "", 
            "title": "Public Methods"
        }, 
        {
            "location": "/validators/file/image-size/#getimagemin", 
            "text": "getImageMin() : array  Returns the minimum valid dimensions as an array with the keys  width  and height .", 
            "title": "getImageMin"
        }, 
        {
            "location": "/validators/file/image-size/#getimagemax", 
            "text": "getImageMax() : array  Returns the maximum valid dimensions as an array with the keys  width  and height .", 
            "title": "getImageMax"
        }, 
        {
            "location": "/validators/file/is-compressed/", 
            "text": "IsCompressed\n\n\nZend\\Validator\\File\\IsCompressed\n checks if a file is a compressed archive,\nsuch as zip or gzip. This validator is based on the\n\nMimeType validator\n, and supports the same methods and options.\n\n\nThe default list of \ncompressed file MIME types\n\ncan be found in the source code.\n\n\nPlease refer to the \nMimeType validator\n for options and public\nmethods.\n\n\nBasic Usage\n\n\n$validator = new \\Zend\\Validator\\File\\IsCompressed();\n\nif ($validator-\nisValid('./myfile.zip')) {\n    // file is valid\n}", 
            "title": "IsCompressed"
        }, 
        {
            "location": "/validators/file/is-compressed/#iscompressed", 
            "text": "Zend\\Validator\\File\\IsCompressed  checks if a file is a compressed archive,\nsuch as zip or gzip. This validator is based on the MimeType validator , and supports the same methods and options.  The default list of  compressed file MIME types \ncan be found in the source code.  Please refer to the  MimeType validator  for options and public\nmethods.", 
            "title": "IsCompressed"
        }, 
        {
            "location": "/validators/file/is-compressed/#basic-usage", 
            "text": "$validator = new \\Zend\\Validator\\File\\IsCompressed();\n\nif ($validator- isValid('./myfile.zip')) {\n    // file is valid\n}", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/validators/file/is-image/", 
            "text": "IsImage\n\n\nZend\\Validator\\File\\IsImage\n checks if a file is an image, such as jpg or png.\nThis validator is based on the \nMimeType validator\n and supports\nthe same methods and options.\n\n\nThe default list of \nimage file MIME types\n\ncan be found in the source code.\n\n\nPlease refer to the \nMimeType validator\n for options and public\nmethods.\n\n\nBasic Usage\n\n\n$validator = new Zend\\Validator\\File\\IsImage();\n\nif ($validator-\nisValid('./myfile.jpg')) {\n    // file is valid\n}", 
            "title": "IsImage"
        }, 
        {
            "location": "/validators/file/is-image/#isimage", 
            "text": "Zend\\Validator\\File\\IsImage  checks if a file is an image, such as jpg or png.\nThis validator is based on the  MimeType validator  and supports\nthe same methods and options.  The default list of  image file MIME types \ncan be found in the source code.  Please refer to the  MimeType validator  for options and public\nmethods.", 
            "title": "IsImage"
        }, 
        {
            "location": "/validators/file/is-image/#basic-usage", 
            "text": "$validator = new Zend\\Validator\\File\\IsImage();\n\nif ($validator- isValid('./myfile.jpg')) {\n    // file is valid\n}", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/validators/file/md5/", 
            "text": "Md5\n\n\nZend\\Validator\\File\\Md5\n allows you to validate if a given file's hashed\ncontents matches the supplied md5 hash(es). It is subclassed from the\n\nHash validator\n to provide a validator that supports only the MD5\nalgorithm.\n\n\n\n\nRequires the hash extension\n\n\nThis validator requires the PHP \nHash extension\n PHP with\nthe \nmd5\n algorithm.\n\n\n\n\nSupported Options\n\n\nThe following set of options are supported:\n\n\n\n\nhash\n: String hash or array of hashes against which to validate.\n\n\n\n\nBasic Usage\n\n\nuse Zend\\Validator\\File\\Md5;\n\n// Does file have the given hash?\n$validator = new Md5('3b3652f336522365223');\n\n// Or, check file against multiple hashes\n$validator = new Md5([\n    '3b3652f336522365223', 'eb3365f3365ddc65365'\n]);\n\n// Or use options notation:\n$validator = new Md5(['hash' =\n [\n    '3b3652f336522365223', 'eb3365f3365ddc65365'\n]]);\n\n\n// Perform validation with file path\nif ($validator-\nisValid('./myfile.txt')) {\n    // file is valid\n}\n\n\n\n\nPublic Methods\n\n\ngetMd5\n\n\ngetMd5() : array\n\n\n\n\nReturns an array of MD5 hashes against which to validate.\n\n\naddMd5\n\n\naddMd5(string|array $options) : void\n\n\n\n\nAdd one or more hashes to validate against.\n\n\nsetMd5\n\n\nsetMd5(string|array $options) : void\n\n\n\n\nOverwrite any previously set hashes with those specified.", 
            "title": "Md5"
        }, 
        {
            "location": "/validators/file/md5/#md5", 
            "text": "Zend\\Validator\\File\\Md5  allows you to validate if a given file's hashed\ncontents matches the supplied md5 hash(es). It is subclassed from the Hash validator  to provide a validator that supports only the MD5\nalgorithm.", 
            "title": "Md5"
        }, 
        {
            "location": "/validators/file/md5/#requires-the-hash-extension", 
            "text": "This validator requires the PHP  Hash extension  PHP with\nthe  md5  algorithm.", 
            "title": "Requires the hash extension"
        }, 
        {
            "location": "/validators/file/md5/#supported-options", 
            "text": "The following set of options are supported:   hash : String hash or array of hashes against which to validate.", 
            "title": "Supported Options"
        }, 
        {
            "location": "/validators/file/md5/#basic-usage", 
            "text": "use Zend\\Validator\\File\\Md5;\n\n// Does file have the given hash?\n$validator = new Md5('3b3652f336522365223');\n\n// Or, check file against multiple hashes\n$validator = new Md5([\n    '3b3652f336522365223', 'eb3365f3365ddc65365'\n]);\n\n// Or use options notation:\n$validator = new Md5(['hash' =  [\n    '3b3652f336522365223', 'eb3365f3365ddc65365'\n]]);\n\n\n// Perform validation with file path\nif ($validator- isValid('./myfile.txt')) {\n    // file is valid\n}", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/validators/file/md5/#public-methods", 
            "text": "", 
            "title": "Public Methods"
        }, 
        {
            "location": "/validators/file/md5/#getmd5", 
            "text": "getMd5() : array  Returns an array of MD5 hashes against which to validate.", 
            "title": "getMd5"
        }, 
        {
            "location": "/validators/file/md5/#addmd5", 
            "text": "addMd5(string|array $options) : void  Add one or more hashes to validate against.", 
            "title": "addMd5"
        }, 
        {
            "location": "/validators/file/md5/#setmd5", 
            "text": "setMd5(string|array $options) : void  Overwrite any previously set hashes with those specified.", 
            "title": "setMd5"
        }, 
        {
            "location": "/validators/file/mime-type/", 
            "text": "MimeType\n\n\nZend\\Validator\\File\\MimeType\n checks the MIME type of files. It will assert\n\ntrue\n when a given file matches any defined MIME type.\n\n\nThis validator is inversely related to the\n\nExcludeMimeType validator\n\n\n\n\nCompatibility\n\n\nThis component will use the \nFileInfo\n extension if it is available. If it's\nnot, it will degrade to the \nmime_content_type()\n function. And if the\nfunction call fails, it will use the MIME type which is given by HTTP. You\nshould be aware of possible security problems when you do not have \nFileInfo\n\nor \nmime_content_type()\n available; the MIME type given by HTTP is not secure\nand can be easily manipulated.\n\n\n\n\nSupported Options\n\n\nThe following set of options are supported:\n\n\n\n\nmimeType\n: Comma-delimited string of MIME types, or array of MIME types,\n  against which to test. Types can be specific (e.g., \nimage/jpg\n), or refer\n  only to the group (e.g., \nimage\n).\n\n\nmagicFile\n: Location of the magicfile to use for MIME type comparisons;\n  defaults to the value of the \nMAGIC\n constant.\n\n\nenableHeaderCheck\n: Boolean flag indicating whether or not to use HTTP\n  headers when determining the MIME type if neither the \nFileInfo\n nor\n  \nmime_magic\n extensions are available; defaults to \nfalse\n.\n\n\n\n\nBasic Usage\n\n\nuse Zend\\Validator\\File\\MimeType;\n\n// Only allow 'gif' or 'jpg' files\n$validator = new MimeType('image/gif,image/jpg');\n\n// ... or with array notation:\n$validator = new MimeType(['image/gif', 'image/jpg']);\n\n// ... or restrict to  entire group of types:\n$validator = new MimeType(['image', 'audio']);\n\n// Specify a different magicFile:\n$validator = new MimeType([\n    'mimeType' =\n ['image/gif', 'image/jpg'],\n    'magicFile' =\n '/path/to/magicfile.mgx',\n]);\n\n// Enable HTTP header scanning (do not do this!):\n$validator = new MimeType([\n    'mimeType' =\n ['image/gif', 'image/jpg'],\n    'enableHeaderCheck' =\n true,\n]);\n\n// Perform validation\nif ($validator-\nisValid('./myfile.jpg')) {\n    // file is valid\n}\n\n\n\n\n\n\nValidating MIME groups is potentially dangerous\n\n\nAllowing \"groups\" of MIME types will accept \nall\n members of this group, even\nif your application does not support them. For instance, When you allow\n\nimage\n you also allow \nimage/xpixmap\n and \nimage/vasa\n, both of which could\nbe problematic.", 
            "title": "MimeType"
        }, 
        {
            "location": "/validators/file/mime-type/#mimetype", 
            "text": "Zend\\Validator\\File\\MimeType  checks the MIME type of files. It will assert true  when a given file matches any defined MIME type.  This validator is inversely related to the ExcludeMimeType validator", 
            "title": "MimeType"
        }, 
        {
            "location": "/validators/file/mime-type/#compatibility", 
            "text": "This component will use the  FileInfo  extension if it is available. If it's\nnot, it will degrade to the  mime_content_type()  function. And if the\nfunction call fails, it will use the MIME type which is given by HTTP. You\nshould be aware of possible security problems when you do not have  FileInfo \nor  mime_content_type()  available; the MIME type given by HTTP is not secure\nand can be easily manipulated.", 
            "title": "Compatibility"
        }, 
        {
            "location": "/validators/file/mime-type/#supported-options", 
            "text": "The following set of options are supported:   mimeType : Comma-delimited string of MIME types, or array of MIME types,\n  against which to test. Types can be specific (e.g.,  image/jpg ), or refer\n  only to the group (e.g.,  image ).  magicFile : Location of the magicfile to use for MIME type comparisons;\n  defaults to the value of the  MAGIC  constant.  enableHeaderCheck : Boolean flag indicating whether or not to use HTTP\n  headers when determining the MIME type if neither the  FileInfo  nor\n   mime_magic  extensions are available; defaults to  false .", 
            "title": "Supported Options"
        }, 
        {
            "location": "/validators/file/mime-type/#basic-usage", 
            "text": "use Zend\\Validator\\File\\MimeType;\n\n// Only allow 'gif' or 'jpg' files\n$validator = new MimeType('image/gif,image/jpg');\n\n// ... or with array notation:\n$validator = new MimeType(['image/gif', 'image/jpg']);\n\n// ... or restrict to  entire group of types:\n$validator = new MimeType(['image', 'audio']);\n\n// Specify a different magicFile:\n$validator = new MimeType([\n    'mimeType' =  ['image/gif', 'image/jpg'],\n    'magicFile' =  '/path/to/magicfile.mgx',\n]);\n\n// Enable HTTP header scanning (do not do this!):\n$validator = new MimeType([\n    'mimeType' =  ['image/gif', 'image/jpg'],\n    'enableHeaderCheck' =  true,\n]);\n\n// Perform validation\nif ($validator- isValid('./myfile.jpg')) {\n    // file is valid\n}", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/validators/file/mime-type/#validating-mime-groups-is-potentially-dangerous", 
            "text": "Allowing \"groups\" of MIME types will accept  all  members of this group, even\nif your application does not support them. For instance, When you allow image  you also allow  image/xpixmap  and  image/vasa , both of which could\nbe problematic.", 
            "title": "Validating MIME groups is potentially dangerous"
        }, 
        {
            "location": "/validators/file/not-exists/", 
            "text": "NotExists\n\n\nZend\\Validator\\File\\NotExists\n checks for the existence of files in specified\ndirectories.\n\n\nThis validator is inversely related to the \nExists validator\n.\n\n\nSupported Options\n\n\nThe following set of options are supported:\n\n\n\n\ndirectory\n: Array of directories or comma-delimited string of directories\n  against which to validate.\n\n\n\n\nBasic Usage\n\n\nuse Zend\\Validator\\File\\NotExists;\n\n// Only allow files that do not exist in ~either~ directories\n$validator = new NotExists('/tmp,/var/tmp');\n\n// ... or with array notation:\n$validator = new NotExists(['/tmp', '/var/tmp']);\n\n// ... or using options notation:\n$validator = new NotExists(['directory' =\n [\n    '/tmp',\n    '/var/tmp',\n]]);\n\n// Perform validation\nif ($validator-\nisValid('/home/myfile.txt')) {\n    // file is valid\n}\n\n\n\n\n\n\nChecks against all directories\n\n\nThis validator checks whether the specified file does not exist in \nany\n of\nthe given directories; validation will fail if the file exists in one (or\nmore) of the given directories.", 
            "title": "NotExists"
        }, 
        {
            "location": "/validators/file/not-exists/#notexists", 
            "text": "Zend\\Validator\\File\\NotExists  checks for the existence of files in specified\ndirectories.  This validator is inversely related to the  Exists validator .", 
            "title": "NotExists"
        }, 
        {
            "location": "/validators/file/not-exists/#supported-options", 
            "text": "The following set of options are supported:   directory : Array of directories or comma-delimited string of directories\n  against which to validate.", 
            "title": "Supported Options"
        }, 
        {
            "location": "/validators/file/not-exists/#basic-usage", 
            "text": "use Zend\\Validator\\File\\NotExists;\n\n// Only allow files that do not exist in ~either~ directories\n$validator = new NotExists('/tmp,/var/tmp');\n\n// ... or with array notation:\n$validator = new NotExists(['/tmp', '/var/tmp']);\n\n// ... or using options notation:\n$validator = new NotExists(['directory' =  [\n    '/tmp',\n    '/var/tmp',\n]]);\n\n// Perform validation\nif ($validator- isValid('/home/myfile.txt')) {\n    // file is valid\n}", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/validators/file/not-exists/#checks-against-all-directories", 
            "text": "This validator checks whether the specified file does not exist in  any  of\nthe given directories; validation will fail if the file exists in one (or\nmore) of the given directories.", 
            "title": "Checks against all directories"
        }, 
        {
            "location": "/validators/file/sha1/", 
            "text": "Sha1\n\n\nZend\\Validator\\File\\Sha1\n allows you to validate if a given file's hashed\ncontents matches the supplied sha1 hash(es). It is subclassed from the\n\nHash validator\n to provide a validator that only supports the \nsha1\n\nalgorithm.\n\n\n\n\nRequires the hash extension\n\n\nThis validator requires the PHP \nHash extension\n with the\n\nsha1\n algorithm.\n\n\n\n\nSupported Options\n\n\nThe following set of options are supported:\n\n\n\n\nhash\n: String hash or array of hashes against which to validate.\n\n\n\n\nBasic Usage\n\n\nuse Zend\\Validator\\File\\Sha1;\n\n// Does file have the given hash?\n$validator = new Sha1('3b3652f336522365223');\n\n// Or check file against multiple hashes:\n$validator = new Sha1([\n    '3b3652f336522365223',\n    'eb3365f3365ddc65365',\n]);\n\n// Or using options notation:\n$validator = new Sha1(['hash' =\n [\n    '3b3652f336522365223',\n    'eb3365f3365ddc65365',\n]]);\n\n// Perform validation with file path\nif ($validator-\nisValid('./myfile.txt')) {\n    // file is valid\n}\n\n\n\n\nPublic Methods\n\n\ngetSha1\n\n\ngetSha1() : array\n\n\n\n\nReturns an array of sha1 hashes against which to validate.\n\n\naddSha1\n\n\naddSha1(string|array $options) : void\n\n\n\n\nAdd one or more hashes to validate against.\n\n\nsetSha1\n\n\nsetSha1(string|array $options) : void\n\n\n\n\nOverwrite any previously set hashes with those specified.", 
            "title": "Sha1"
        }, 
        {
            "location": "/validators/file/sha1/#sha1", 
            "text": "Zend\\Validator\\File\\Sha1  allows you to validate if a given file's hashed\ncontents matches the supplied sha1 hash(es). It is subclassed from the Hash validator  to provide a validator that only supports the  sha1 \nalgorithm.", 
            "title": "Sha1"
        }, 
        {
            "location": "/validators/file/sha1/#requires-the-hash-extension", 
            "text": "This validator requires the PHP  Hash extension  with the sha1  algorithm.", 
            "title": "Requires the hash extension"
        }, 
        {
            "location": "/validators/file/sha1/#supported-options", 
            "text": "The following set of options are supported:   hash : String hash or array of hashes against which to validate.", 
            "title": "Supported Options"
        }, 
        {
            "location": "/validators/file/sha1/#basic-usage", 
            "text": "use Zend\\Validator\\File\\Sha1;\n\n// Does file have the given hash?\n$validator = new Sha1('3b3652f336522365223');\n\n// Or check file against multiple hashes:\n$validator = new Sha1([\n    '3b3652f336522365223',\n    'eb3365f3365ddc65365',\n]);\n\n// Or using options notation:\n$validator = new Sha1(['hash' =  [\n    '3b3652f336522365223',\n    'eb3365f3365ddc65365',\n]]);\n\n// Perform validation with file path\nif ($validator- isValid('./myfile.txt')) {\n    // file is valid\n}", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/validators/file/sha1/#public-methods", 
            "text": "", 
            "title": "Public Methods"
        }, 
        {
            "location": "/validators/file/sha1/#getsha1", 
            "text": "getSha1() : array  Returns an array of sha1 hashes against which to validate.", 
            "title": "getSha1"
        }, 
        {
            "location": "/validators/file/sha1/#addsha1", 
            "text": "addSha1(string|array $options) : void  Add one or more hashes to validate against.", 
            "title": "addSha1"
        }, 
        {
            "location": "/validators/file/sha1/#setsha1", 
            "text": "setSha1(string|array $options) : void  Overwrite any previously set hashes with those specified.", 
            "title": "setSha1"
        }, 
        {
            "location": "/validators/file/size/", 
            "text": "Size\n\n\nZend\\Validator\\File\\Size\n checks for the size of a file.\n\n\nSupported Options\n\n\nThe following set of options are supported:\n\n\n\n\nmin\n: Minimum file size in integer bytes, or in string SI notation; \nnull\n\n  indicates no minimum required.\n\n\nmax\n: maximum file size in integer bytes, or in string SI notation; \nnull\n\n  indicates no maximum required.\n\n\nuseByteString\n: Boolean flag indicating whether to dispaly error messages\n  using SI notation (default, \ntrue\n), or in bytes (\nfalse\n).\n\n\n\n\nSI units supported are: kB, MB, GB, TB, PB, and EB. All sizes are converted\nusing 1024 as the base value (ie. 1kB == 1024 bytes, 1MB == 1024kB).\n\n\nBasic Usage\n\n\nuse Zend\\Validator\\File\\Size;\n\n// Limit the file size to 40000 bytes\n$validator = new Size(40000);\n\n// Limit the file size to between 10kB and 4MB\n$validator = new Size([\n    'min' =\n '10kB',\n    'max' =\n '4MB',\n]);\n\n// Perform validation with file path\nif ($validator-\nisValid('./myfile.txt')) {\n    // file is valid\n}", 
            "title": "Size"
        }, 
        {
            "location": "/validators/file/size/#size", 
            "text": "Zend\\Validator\\File\\Size  checks for the size of a file.", 
            "title": "Size"
        }, 
        {
            "location": "/validators/file/size/#supported-options", 
            "text": "The following set of options are supported:   min : Minimum file size in integer bytes, or in string SI notation;  null \n  indicates no minimum required.  max : maximum file size in integer bytes, or in string SI notation;  null \n  indicates no maximum required.  useByteString : Boolean flag indicating whether to dispaly error messages\n  using SI notation (default,  true ), or in bytes ( false ).   SI units supported are: kB, MB, GB, TB, PB, and EB. All sizes are converted\nusing 1024 as the base value (ie. 1kB == 1024 bytes, 1MB == 1024kB).", 
            "title": "Supported Options"
        }, 
        {
            "location": "/validators/file/size/#basic-usage", 
            "text": "use Zend\\Validator\\File\\Size;\n\n// Limit the file size to 40000 bytes\n$validator = new Size(40000);\n\n// Limit the file size to between 10kB and 4MB\n$validator = new Size([\n    'min' =  '10kB',\n    'max' =  '4MB',\n]);\n\n// Perform validation with file path\nif ($validator- isValid('./myfile.txt')) {\n    // file is valid\n}", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/validators/file/upload/", 
            "text": "Upload\n\n\nZend\\Validator\\File\\Upload\n validates that a file upload operation was\nsuccessful.\n\n\nSupported Options\n\n\nZend\\Validator\\File\\Upload\n supports the following options:\n\n\n\n\nfiles\n: array of file uploads. This is generally the \n$_FILES\n array, but\n  should be normalized per the details in \nPSR-7\n\n  (which is also how \nthe zend-http Request\n\n  normalizes the array).\n\n\n\n\nBasic Usage\n\n\nuse Zend\\Validator\\File\\Upload;\n\n// Using zend-http's request:\n$validator = new Upload($request-\ngetFiles());\n\n// Or using options notation:\n$validator = new Upload(['files' =\n $request-\ngetFiles()]);\n\n// Validate:\nif ($validator-\nisValid('foo')) {\n    // \nfoo\n file upload was successful\n}", 
            "title": "Upload"
        }, 
        {
            "location": "/validators/file/upload/#upload", 
            "text": "Zend\\Validator\\File\\Upload  validates that a file upload operation was\nsuccessful.", 
            "title": "Upload"
        }, 
        {
            "location": "/validators/file/upload/#supported-options", 
            "text": "Zend\\Validator\\File\\Upload  supports the following options:   files : array of file uploads. This is generally the  $_FILES  array, but\n  should be normalized per the details in  PSR-7 \n  (which is also how  the zend-http Request \n  normalizes the array).", 
            "title": "Supported Options"
        }, 
        {
            "location": "/validators/file/upload/#basic-usage", 
            "text": "use Zend\\Validator\\File\\Upload;\n\n// Using zend-http's request:\n$validator = new Upload($request- getFiles());\n\n// Or using options notation:\n$validator = new Upload(['files' =  $request- getFiles()]);\n\n// Validate:\nif ($validator- isValid('foo')) {\n    //  foo  file upload was successful\n}", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/validators/file/upload-file/", 
            "text": "UploadFile\n\n\nZend\\Validator\\File\\UploadFile\n checks whether a single file has been uploaded\nvia a form \nPOST\n and will return descriptive messages for any upload errors.\n\n\nBasic Usage\n\n\nuse Zend\\Http\\PhpEnvironment\\Request;\nuse Zend\\Validator\\File\\UploadFile;\n\n$request = new Request();\n$files   = $request-\ngetFiles();\n// i.e. $files['my-upload']['error'] == 0\n\n$validator = new UploadFile();\nif ($validator-\nisValid($files['my-upload'])) {\n    // file is valid\n}\n\n\n\n\nUsage with zend-inputfilter\n\n\nWhen using zend-inputfilter's \nFileInput\n,\nthis validator will be automatically prepended to the validator chain.", 
            "title": "UploadFile"
        }, 
        {
            "location": "/validators/file/upload-file/#uploadfile", 
            "text": "Zend\\Validator\\File\\UploadFile  checks whether a single file has been uploaded\nvia a form  POST  and will return descriptive messages for any upload errors.", 
            "title": "UploadFile"
        }, 
        {
            "location": "/validators/file/upload-file/#basic-usage", 
            "text": "use Zend\\Http\\PhpEnvironment\\Request;\nuse Zend\\Validator\\File\\UploadFile;\n\n$request = new Request();\n$files   = $request- getFiles();\n// i.e. $files['my-upload']['error'] == 0\n\n$validator = new UploadFile();\nif ($validator- isValid($files['my-upload'])) {\n    // file is valid\n}", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/validators/file/upload-file/#usage-with-zend-inputfilter", 
            "text": "When using zend-inputfilter's  FileInput ,\nthis validator will be automatically prepended to the validator chain.", 
            "title": "Usage with zend-inputfilter"
        }, 
        {
            "location": "/validators/file/word-count/", 
            "text": "WordCount\n\n\nZend\\Validator\\File\\WordCount\n validates that the number of words within a file\nmatch the specified criteria.\n\n\nSupported Options\n\n\nThe following set of options are supported:\n\n\n\n\nmin\n: the minimum number of words required; \nnull\n indicates no minimum.\n\n\nmax\n: the maximum number of words required; \nnull\n indicates no maximum.\n\n\n\n\nBasic Usage\n\n\nuse Zend\\Validator\\File\\WordCount;\n\n// Limit the amount of words to a maximum of 2000:\n$validator = new WordCount(2000);\n\n// Limit the amount of words to between 100 and 5000:\n$validator = new WordCount(100, 5000);\n\n// ... or use options notation:\n$validator = new WordCount([\n    'min' =\n 1000,\n    'max' =\n 5000,\n]);\n\n// Perform validation with file path\nif ($validator-\nisValid('./myfile.txt')) {\n    // file is valid\n}", 
            "title": "WordCount"
        }, 
        {
            "location": "/validators/file/word-count/#wordcount", 
            "text": "Zend\\Validator\\File\\WordCount  validates that the number of words within a file\nmatch the specified criteria.", 
            "title": "WordCount"
        }, 
        {
            "location": "/validators/file/word-count/#supported-options", 
            "text": "The following set of options are supported:   min : the minimum number of words required;  null  indicates no minimum.  max : the maximum number of words required;  null  indicates no maximum.", 
            "title": "Supported Options"
        }, 
        {
            "location": "/validators/file/word-count/#basic-usage", 
            "text": "use Zend\\Validator\\File\\WordCount;\n\n// Limit the amount of words to a maximum of 2000:\n$validator = new WordCount(2000);\n\n// Limit the amount of words to between 100 and 5000:\n$validator = new WordCount(100, 5000);\n\n// ... or use options notation:\n$validator = new WordCount([\n    'min' =  1000,\n    'max' =  5000,\n]);\n\n// Perform validation with file path\nif ($validator- isValid('./myfile.txt')) {\n    // file is valid\n}", 
            "title": "Basic Usage"
        }
    ]
}